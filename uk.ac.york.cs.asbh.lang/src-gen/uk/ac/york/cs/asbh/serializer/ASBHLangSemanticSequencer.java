/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package uk.ac.york.cs.asbh.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.york.cs.asbh.lang.cs2as.source.PathElementCS;
import uk.ac.york.cs.asbh.lang.cs2as.source.PathNameCS;
import uk.ac.york.cs.asbh.lang.cs2as.source.SRoot;
import uk.ac.york.cs.asbh.lang.cs2as.source.SourcePackage;
import uk.ac.york.cs.asbh.lang.cs2as.source.X;
import uk.ac.york.cs.asbh.lang.cs2as.source.Y1;
import uk.ac.york.cs.asbh.lang.cs2as.source.Y2;
import uk.ac.york.cs.asbh.lang.cs2as.source.Z;
import uk.ac.york.cs.asbh.services.ASBHLangGrammarAccess;

@SuppressWarnings("all")
public class ASBHLangSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ASBHLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == SourcePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case SourcePackage.PATH_ELEMENT_CS:
				sequence_PathElementCS(context, (PathElementCS) semanticObject); 
				return; 
			case SourcePackage.PATH_NAME_CS:
				sequence_PathNameCS(context, (PathNameCS) semanticObject); 
				return; 
			case SourcePackage.SROOT:
				sequence_Root(context, (SRoot) semanticObject); 
				return; 
			case SourcePackage.X:
				sequence_X(context, (X) semanticObject); 
				return; 
			case SourcePackage.Y1:
				sequence_Y1(context, (Y1) semanticObject); 
				return; 
			case SourcePackage.Y2:
				sequence_Y2(context, (Y2) semanticObject); 
				return; 
			case SourcePackage.Z:
				sequence_Z(context, (Z) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     PathElementCS returns PathElementCS
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_PathElementCS(ISerializationContext context, PathElementCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, SourcePackage.Literals.PATH_ELEMENT_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, SourcePackage.Literals.PATH_ELEMENT_CS__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathElementCSAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathNameCS returns PathNameCS
	 *
	 * Constraint:
	 *     (path+=PathElementCS path+=PathElementCS*)
	 */
	protected void sequence_PathNameCS(ISerializationContext context, PathNameCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Root returns SRoot
	 *
	 * Constraint:
	 *     ownedX+=X*
	 */
	protected void sequence_Root(ISerializationContext context, SRoot semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     X returns X
	 *
	 * Constraint:
	 *     (name=ID (isA1?='isA1' | isA2?='isA2')? ownsY+=Y*)
	 */
	protected void sequence_X(ISerializationContext context, X semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Y returns Y1
	 *     Y1 returns Y1
	 *
	 * Constraint:
	 *     (name=ID ownsZ=Z?)
	 */
	protected void sequence_Y1(ISerializationContext context, Y1 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Y returns Y2
	 *     Y2 returns Y2
	 *
	 * Constraint:
	 *     (name=ID ownsZ=Z?)
	 */
	protected void sequence_Y2(ISerializationContext context, Y2 semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Z returns Z
	 *
	 * Constraint:
	 *     refers=PathNameCS?
	 */
	protected void sequence_Z(ISerializationContext context, Z semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
