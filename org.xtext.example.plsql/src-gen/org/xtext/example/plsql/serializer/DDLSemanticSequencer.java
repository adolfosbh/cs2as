/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.plsql.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.plsql.dDL.Alter_table;
import org.xtext.example.plsql.dDL.Colname;
import org.xtext.example.plsql.dDL.Column;
import org.xtext.example.plsql.dDL.Comment;
import org.xtext.example.plsql.dDL.Constraint;
import org.xtext.example.plsql.dDL.Create_sequence;
import org.xtext.example.plsql.dDL.Create_table;
import org.xtext.example.plsql.dDL.DDLPackage;
import org.xtext.example.plsql.dDL.Data_definition;
import org.xtext.example.plsql.dDL.Foreign_key;
import org.xtext.example.plsql.dDL.ISNULL;
import org.xtext.example.plsql.dDL.Primary_key;
import org.xtext.example.plsql.dDL.Sequence_options;
import org.xtext.example.plsql.dDL.TYPE;
import org.xtext.example.plsql.dDL.Tabname;
import org.xtext.example.plsql.dDL.Unique_key;
import org.xtext.example.plsql.services.DDLGrammarAccess;

@SuppressWarnings("all")
public class DDLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DDLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DDLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DDLPackage.ALTER_TABLE:
				sequence_Alter_table(context, (Alter_table) semanticObject); 
				return; 
			case DDLPackage.COLNAME:
				sequence_Colname(context, (Colname) semanticObject); 
				return; 
			case DDLPackage.COLUMN:
				sequence_Column(context, (Column) semanticObject); 
				return; 
			case DDLPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case DDLPackage.CONSTRAINT:
				sequence_Constraint(context, (Constraint) semanticObject); 
				return; 
			case DDLPackage.CREATE_SEQUENCE:
				sequence_Create_sequence(context, (Create_sequence) semanticObject); 
				return; 
			case DDLPackage.CREATE_TABLE:
				sequence_Create_table(context, (Create_table) semanticObject); 
				return; 
			case DDLPackage.DATA_DEFINITION:
				sequence_Data_definition(context, (Data_definition) semanticObject); 
				return; 
			case DDLPackage.FOREIGN_KEY:
				sequence_Foreign_key(context, (Foreign_key) semanticObject); 
				return; 
			case DDLPackage.ISNULL:
				sequence_ISNULL(context, (ISNULL) semanticObject); 
				return; 
			case DDLPackage.PRIMARY_KEY:
				sequence_Primary_key(context, (Primary_key) semanticObject); 
				return; 
			case DDLPackage.SEQUENCE_OPTIONS:
				sequence_Sequence_options(context, (Sequence_options) semanticObject); 
				return; 
			case DDLPackage.TYPE:
				sequence_TYPE(context, (TYPE) semanticObject); 
				return; 
			case DDLPackage.TABNAME:
				sequence_Tabname(context, (Tabname) semanticObject); 
				return; 
			case DDLPackage.UNIQUE_KEY:
				sequence_Unique_key(context, (Unique_key) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Definition returns Alter_table
	 *     Alter_table returns Alter_table
	 *
	 * Constraint:
	 *     (tabname=Tabname ((add='ADD' constraint=Constraint) | (enable='ENABLE' id=ID)))
	 */
	protected void sequence_Alter_table(ISerializationContext context, Alter_table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Colname returns Colname
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_Colname(ISerializationContext context, Colname semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DDLPackage.Literals.COLNAME__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DDLPackage.Literals.COLNAME__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getColnameAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Column returns Column
	 *
	 * Constraint:
	 *     (id=ID type=TYPE number=INT? isNull=ISNULL?)
	 */
	protected void sequence_Column(ISerializationContext context, Column semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Comment
	 *     Comment returns Comment
	 *
	 * Constraint:
	 *     ((tabname=Tabname | (columnId=ID colname=Colname)) string=STRING)
	 */
	protected void sequence_Comment(ISerializationContext context, Comment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Constraint returns Constraint
	 *
	 * Constraint:
	 *     (id=ID key=Key)
	 */
	protected void sequence_Constraint(ISerializationContext context, Constraint semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DDLPackage.Literals.CONSTRAINT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DDLPackage.Literals.CONSTRAINT__ID));
			if (transientValues.isValueTransient(semanticObject, DDLPackage.Literals.CONSTRAINT__KEY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DDLPackage.Literals.CONSTRAINT__KEY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstraintAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getConstraintAccess().getKeyKeyParserRuleCall_2_0(), semanticObject.getKey());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Create_sequence
	 *     Create_sequence returns Create_sequence
	 *
	 * Constraint:
	 *     (id=ID sequence_options+=Sequence_options*)
	 */
	protected void sequence_Create_sequence(ISerializationContext context, Create_sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Create_table
	 *     Create_table returns Create_table
	 *
	 * Constraint:
	 *     (id=ID columns+=Column columns+=Column* constraints+=Constraint*)
	 */
	protected void sequence_Create_table(ISerializationContext context, Create_table semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Data_definition returns Data_definition
	 *
	 * Constraint:
	 *     definitions+=Definition+
	 */
	protected void sequence_Data_definition(ISerializationContext context, Data_definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Foreign_key
	 *     Foreign_key returns Foreign_key
	 *
	 * Constraint:
	 *     (colNames+=Colname tabname=Tabname colNames+=Colname)
	 */
	protected void sequence_Foreign_key(ISerializationContext context, Foreign_key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ISNULL returns ISNULL
	 *
	 * Constraint:
	 *     (null?='NULL' | nonNull?='NOT')
	 */
	protected void sequence_ISNULL(ISerializationContext context, ISNULL semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Primary_key
	 *     Primary_key returns Primary_key
	 *
	 * Constraint:
	 *     (colNames+=Colname colNames+=Colname*)
	 */
	protected void sequence_Primary_key(ISerializationContext context, Primary_key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sequence_options returns Sequence_options
	 *
	 * Constraint:
	 *     (
	 *         increment='INCREMENT' | 
	 *         start='START' | 
	 *         maxvalue='MAXVALUE' | 
	 *         nomaxvalue='NOMAXVALUE' | 
	 *         minvalue='MINVALUE' | 
	 *         nominvalue='NOMINVALUE' | 
	 *         cycle='CYCLE' | 
	 *         nocycle='NOCYCLE' | 
	 *         cache='CACHE' | 
	 *         nocache='NOCACHE' | 
	 *         order='ORDER' | 
	 *         noorder='NOORDER'
	 *     )
	 */
	protected void sequence_Sequence_options(ISerializationContext context, Sequence_options semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TYPE returns TYPE
	 *
	 * Constraint:
	 *     (id='NUMBER' | id='VARCHAR2' | id='DATE')
	 */
	protected void sequence_TYPE(ISerializationContext context, TYPE semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Tabname returns Tabname
	 *
	 * Constraint:
	 *     (id=ID? basename=ID)
	 */
	protected void sequence_Tabname(ISerializationContext context, Tabname semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Key returns Unique_key
	 *     Unique_key returns Unique_key
	 *
	 * Constraint:
	 *     (colNames+=Colname colNames+=Colname*)
	 */
	protected void sequence_Unique_key(ISerializationContext context, Unique_key semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
