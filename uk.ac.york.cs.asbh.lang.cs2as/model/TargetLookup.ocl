import 'EnvExample1.ecore'
--import 'Environment.ocl' FIXME imported OCL doesn't work
import 'TargetMM1.ecore'

package ocl
---- Default Environment related functionality
context OclElement
--	
def : env() : env::Environment =
	_env(null)

def : _env(child : OclElement) : env::Environment =
	parentEnv()
	
def : parentEnv() : env::Environment =
	let parent = oclContainer() in if parent = null then env::Environment { } else parent._env(self) endif
endpackage 

package env

-- Lookup operations
context Environment
-- Epsilon can't deal with this. The property is needed in the meta-model
-- def : namedElements : OrderedSet(classes::NamedElement) = OrderedSet{}
-- def : parentEnv : Environment = null

-- General Environment configuration operations
def : addElement(element : target::NamedElement) : Environment =
	Environment{
		namedElements = namedElements->asSequence() -- FIXME bug 460682
			->including(element)
	}
	
def : addElements(elements : Collection(target::NamedElement)) : Environment =
	Environment{
		namedElements = namedElements->asSequence() -- FIXME bug 460682
			->includingAll(elements)
	}
	
def : nestedEnv() : Environment = 
	Environment {
		parentEnv = self
	}
	
def : mergEnv(env : Environment) : Environment =
	Environment {
		namedElements = namedElements->includingAll(env.namedElements)
	}

-- General Environment access operations
def : getNamedElements(name : String) : OrderedSet(target::NamedElement) =
	namedElements->select(x | x.name = name)

-- Specific lookup operations 
def: _lookupBs(bName : String) : OrderedSet(target::B) =
	namedElements->selectByKind(target::B)->select(name = bName)
--	let foundBs : OrderedSet(target::B) = namedElements->selectByKind(target::B)->select(name = bName) in
--	if foundBs->isEmpty()
--	then if parentEnv.oclIsUndefined()
--	     then foundBs
--	     else parentEnv._lookupBs(bName)
--	     endif
--	else foundBs
--	endif

def: _lookupCs(cName : String) : OrderedSet(target::C) =
	namedElements->selectByKind(target::C)->select(name = cName)
--	let foundCs : OrderedSet(target::C) = namedElements->selectByKind(target::C)->select(name = cName) in
--	if foundCs->isEmpty()
--	then if parentEnv.oclIsUndefined()
--	     then foundCs
--	     else parentEnv._lookupCs(cName)
--	     endif
--	else foundCs
--	endif

def: lookupB(name : String) : target::B =
	-- FIXME if not found, lookupBs(name)->any gives an execution error, for the time being we return an null B
	let foundBs = _lookupBs(name) in
	if foundBs->isEmpty()
	then invalid
	else foundBs->any(true) 
	endif
	
	
def: lookupC(name : String) : target::C =
	let foundCs = _lookupCs(name) in
	if foundCs->isEmpty()
	then invalid
	else foundCs->any(true) 
	endif

endpackage

package target

context TRoot
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv()
	
context A1
def : _env(child : ocl::OclElement) : env::Environment =
	_env_B(child)
	
def : _env_B(child : ocl::OclElement) : env::Environment =
	let ownedBs = self.ownsB
	in parentEnv().nestedEnv()
		.addElements(ownedBs->select(x | ownedBs->indexOf(x) < ownedBs->indexOf(child)))

context A2
def : _env(child : ocl::OclElement) : env::Environment =
	_env_C(child)
	
def : _env_C(child : ocl::OclElement) : env::Environment =
	let ownedCs = self.ownsC
	in parentEnv().nestedEnv()
		.addElements(ownedCs->select(x| ownedCs->indexOf(x) < ownedCs->indexOf(child)))

context B
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv()
	
context C
def : _env(child : ocl:: OclElement) : env::Environment =
	parentEnv()

context D
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv()


-- Specifying parent() env() operations

context TRoot
def : parentEnv() : env::Environment =
	env::Environment{}
	
context A1
def : parentEnv() : env::Environment =
	let parent = oclContainer()
	in parent.oclAsType(TRoot)._env(self)
	

context A2
def : parentEnv() : env::Environment =
	let parent = oclContainer()
	in parent.oclAsType(TRoot)._env(self)
	


context B
def : env() : env::Environment =
	self._env(null)
	
def : parentEnv() : env::Environment =
	let parent = oclContainer()
	in parent.oclAsType(A1)._env(self)
	
context C
def : env() : env::Environment =
	self._env(null)
	
def : parentEnv() : env::Environment =
	let parent = oclContainer()
	in parent.oclAsType(A2)._env(self)

context D
	
def : parentEnv() : env::Environment =
	let parent = oclContainer()
	in
		if parent.oclIsKindOf(B)
		then parent.oclAsType(B)._env(self)
		else parent.oclAsType(C)._env(self)
		endif
	
endpackage
