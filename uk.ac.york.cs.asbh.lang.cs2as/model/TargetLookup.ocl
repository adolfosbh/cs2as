import 'EnvExample1.ecore'
--import 'Environment.ocl' FIXME imported OCL doesn't work
import 'SourceMM1.ecore'
import 'TargetMM1.ecore'

package ocl
---- Default Environment related functionality
context OclElement
--	
def : env() : env::Environment =
	_env(null)

def : _env(child : OclElement) : env::Environment =
	parentEnv()
	
def : parentEnv() : env::Environment =
	let parent = oclContainer() in if parent = null then env::Environment { } else parent._env(self) endif
endpackage 

package env

-- Lookup operations
context Environment
def : nestedEnv() : Environment = 
	Environment {
		parentEnv = self
	}

-- TODO This is not needed. Can be removed
---- General Environment access operations
--def : getNamedElements(name : String) : OrderedSet(target::NamedElement) =
--	namedElements->select(x | x.name = name)

endpackage

package target

-- Lookup
context Visitable		
def : _lookupNamespaces(env : env::Environment, path : source::PathElementCS, local : Boolean) : Namespace[*] =
	let foundNS = env.namedElements->selectByKind(Namespace)->select(name = path.name) 
	in  if foundNS->isEmpty() and not (env.parentEnv = null) and not local 
		then _lookupNamespaces(env.parentEnv, path, local)
		else foundNS
		endif

def : _lookupNamespace(path : source::PathElementCS, local : Boolean) : Namespace[?] =
	_lookupNamespaces(env(), path, local)->any(true) -- LookupVisitor will report ambiguous result
		
def : lookupNamespace(pathSeq : OrderedSet(source::PathElementCS)) : Namespace[?] =
	if pathSeq->size() = 1
	then _lookupNamespace(pathSeq->first(), false)
	else lookupNamespace(pathSeq->subOrderedSet(1,pathSeq->size()-1))?._lookupNamespace(pathSeq->last(), true)
	endif

def: _lookupBs(env : env::Environment, path : source::PathElementCS, local : Boolean) : B[*] =
	let	foundBs = env.namedElements->selectByKind(B)->select(name = path.name)
	in	if foundBs->isEmpty() and not (env.parentEnv = null) and not local 
		then _lookupBs(env.parentEnv, path, local)
		else foundBs
		endif

def : _lookupB(path : source::PathElementCS, local : Boolean) : B[?] =
	let foundBs = _lookupBs(env(), path, local)
	in	if foundBs->isEmpty()
		then null
		else foundBs->any(true) -- LookupVisitor will report ambiguous result
		endif

def : lookupB(pathSeq : OrderedSet(source::PathElementCS)) : B[?] = 
	if pathSeq->size() = 1
	then _lookupB(pathSeq->first(), false)
	else lookupNamespace(pathSeq->subOrderedSet(1,pathSeq->size()-1))?._lookupB(pathSeq->last(), true)
	endif

	
def: _lookupCs(env : env::Environment, path : source::PathElementCS, local : Boolean) : C[*] =
	let	foundCs = env.namedElements->selectByKind(C)->select(name = path.name)
	in	if foundCs->isEmpty() and not (env.parentEnv = null) and not local 
		then _lookupBs(env.parentEnv, path, local)
		else foundCs
		endif

def : _lookupC(path : source::PathElementCS, local : Boolean) : C[?] =
	let foundCs = _lookupCs(env(), path, local)
	in if foundCs->isEmpty()
		then null
		else foundCs->any(true) -- LookupVisitor will report ambiguous result
		endif
		
def : lookupC(pathSeq : OrderedSet(source::PathElementCS)) : C[?] = 
	if pathSeq->size() = 1
	then _lookupC(pathSeq->first(), false)
	else lookupNamespace(pathSeq->subOrderedSet(1,pathSeq->size()-1))?._lookupC(pathSeq->last(), true)
	endif
	
context D
def : lookupB(z : source::Z) : B =
	if z.refers = null
	then null 
	else lookupB(z.refers.path)
	endif

def : lookupC(z : source::Z) : C =
	if z.refers = null
	then null 
	else lookupC(z.refers.path)
	endif
	
-- Enviroment computation
context TRoot
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv().nestedEnv()
		.addElements(ownedA)
	
context A1
def : _env(child : ocl::OclElement) : env::Environment =
-- FIXME LookupVisitor doesn't handle any other operation called from this one. Inline here, for the time being
--	_env_B(child)
	let ownedBs = self.ownsB
	in if child = null -- child = null, then the lookup is a qualified one, hence, add all children
		then parentEnv().nestedEnv().addElements(ownedBs)
		else parentEnv().nestedEnv().addElements(ownedBs->select(x | ownedBs->indexOf(x) < ownedBs->indexOf(child)))
		endif

	
--def : _env_B(child : ocl::OclElement) : env::Environment =
--	let ownedBs = self.ownsB
--	in parentEnv().nestedEnv()
--		.addElements(ownedBs->select(x | ownedBs->indexOf(x) < ownedBs->indexOf(child)))

context A2
def : _env(child : ocl::OclElement) : env::Environment =
-- FIXME LookupVisitor doesn't handle any other operation called from this one. Inline here, for the time being
--	_env_C(child)
	let ownedCs = self.ownsC
	in if child = null	-- child = null, then the lookup is a qualified one, hence, add all children
		then parentEnv().nestedEnv().addElements(ownedCs) 
		else parentEnv().nestedEnv().addElements(ownedCs->select(x| ownedCs->indexOf(x) < ownedCs->indexOf(child)))
		endif

	
--def : _env_C(child : ocl::OclElement) : env::Environment =
--	let ownedCs = self.ownsC
--	in parentEnv().nestedEnv()
--		.addElements(ownedCs->select(x| ownedCs->indexOf(x) < ownedCs->indexOf(child)))

context B
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv()
	
context C
def : _env(child : ocl:: OclElement) : env::Environment =
	parentEnv()

context D
def : _env(child : ocl::OclElement) : env::Environment =
	parentEnv()
	
endpackage
