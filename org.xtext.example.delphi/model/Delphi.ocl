import  cs : 'generated/Delphi.ecore#/' 
import  as : 'astm.ecore' 
import 'DelphiHelpers.ocl'
import 'DelphiLookup.ocl'
import 'DelphiDisambiguation.ocl'
package cs

context mainRule
def : ast() : as::astm::Project =
as::astm::Project {
	files = OrderedSet{self.file.ast()}
}

context file
def : ast() : as::astm::CompilationUnit =
	null -- to be overriden 

context unit
def : ast() : as::astm::DelphiUnit =
as::astm::DelphiUnit {
	name = astm::Name {
				nameString = id.extract()
			}, 
language = 'Delphi' , 
interface = interfaceSect.ast(), 
implementation = implementationSect.ast(), 
locationInfo = astm::SourceLocation {
				inSourceFile = astm::SourceFile {
						}
			} 
}
context interfaceSection
def : ast() : as::astm::DelphiInterfaceSection =
as::astm::DelphiInterfaceSection { 
	fragments = self.interfaceDecl.getFragments()
}


	
context constantDecl
def : ast() : as::astm::VariableDefinition =
as::astm::VariableDefinition {
	identifierName = astm::Name {
				nameString = id.extract()
			}, 
initialValue = const.ast() 
}

context implementationSection
def : ast() : as::astm::DelphiImplementationSection =
as::astm::DelphiImplementationSection {  
	fragments = self.declSect.getFragments()
}

   
context labelDeclSection
def : ast() : as::astm::LabelDefinition =
	as::astm::LabelDefinition {
	}
	
context expression
def : ast() : as::astm::Expression =
	null -- to be overriden

context constExpr
def : ast() : as::astm::Expression =
	null -- to be overriden
	
context ConstExp
def : ast() : as::astm::Expression =
	exp.ast()

context MultipleConstExp
def : ast() : as::astm::Expression =
	exps.ast()->first()
	
context RecordConstExp
def : ast() : as::astm::Expression =
	exps.constExp.ast()->first()
		
context typeDecl
def : ast() : as::astm::TypeDefinition =
as::astm::TypeDefinition {
	name = astm::Name {
				nameString = id.extract()
			} 
}
context varDecl
def : ast() : as::astm::VariableDefinition =
as::astm::VariableDefinition {
	identifierName = astm::Name {
				nameString = idList.extract()
			}, 
definitionType = self.type.ast(), 
isMutable = true  
}

context type
def : ast() : as::astm::TypeReference =
	null -- to be overriden
	


	
context procedureDecl
def : ast() : as::astm::FunctionDefinition =
as::astm::FunctionDefinition {
	identifierName = astm::Name {
				nameString = heading.id.extract()
			}, 
	_body = OrderedSet{self.block.ast()} 
}

context functionDecl
def : ast() : as::astm::FunctionDefinition =
as::astm::FunctionDefinition {
	identifierName = astm::Name {
				nameString = heading.id.extract()
			}, 
	_body = OrderedSet{self.block.ast()} 
}
	
context block
def : ast() : as::astm::DelphiBlockStatement =
as::astm::DelphiBlockStatement {
	declarations = declSect?.getFragments(),
subStatements = compound.stamtList.statments.ast() 
}

context statement
def : ast() : as::astm::Statement =
	self.statement.ast()
	
context unlabelledStatement
def : ast() : as::astm::Statement =
	null -- to be overriden

context assignmentStmnt
def : ast() : as::astm::ExpressionStatement =
as::astm::ExpressionStatement {
	expression = astm::BinaryExpression {
				leftOperand = self.designator.ast(),
				operator = astm::Assign {},
				rightOperand = exp.ast()
			} 
}
context callStmnt
def : ast() : as::astm::ExpressionStatement =
as::astm::ExpressionStatement {
	expression = astm::FunctionCallExpression {
				calledFunction = self.designator.ast(),
				actualParams = args.createActualParams()
			} 
}
context withStmt
def : ast() : as::astm::DelphiWithStatement =
as::astm::DelphiWithStatement {
	withs = _vars.ids.ast(), 
subStatements = OrderedSet{stmt.ast()} 
}
context ifStmt
def : ast() : as::astm::IfStatement =
as::astm::IfStatement {
	condition = condition.ast(), 
thenBody = _then.ast(), 
elseBody = _else.ast() 
}
context caseStmt
def : ast() : as::astm::SwitchStatement =
as::astm::SwitchStatement {
	switchExpression = self.expression.ast(), 
cases = cases.ast() 
}
context caseSelector
def : ast() : as::astm::CaseBlock =
as::astm::CaseBlock {
	caseExpressions = labels->collect(x | x.first.ast()->including(x.last . ast())), 
_body = OrderedSet{stmt.ast()} 
}

context tryStmt
def : ast() : as::astm::TryStatement =
as::astm::TryStatement {
	guardedStatement = self.stmtList.statments->first().ast(),  
	finalStatement = final.statments->first().ast() 
}

context designator
def : ast() : as::astm::NameReference =
if isIdentifierRef()
then as::astm::IdentifierReference {
	name = astm::Name {
				nameString = subpart.part.extract()
			}, 
refersTo = getDefinition() 
}
else
	if isQualifiedOverData()
	then as::astm::QualifiedOverData {
		name = astm::Name {
					nameString = subpart.part.extract()
				}, 
--	member = designator.ast().oclAsType(as::astm::IdentifierReference), 
	refersTo = getDefinition() 
	}
	else
		invalid
	endif
endif

context CSTrace
def : ast() : as::astm::Visitable =
	null -- to override
	
context ident
def : ast() : as::astm::DefinitionObject =
let parent = oclContainer().oclAsType(CSTrace).ast,
    method  = parent.lookupFunctionDefinition(self.extract())
in if method <> null then method else parent.lookupVariableDefinition(self.extract()) endif

context relExp
def : ast() : as::astm::BinaryExpression =
as::astm::BinaryExpression {
	leftOperand = left.ast(), 
rightOperand = right.ast(), 
operator = if self.relOp.op = '='  then astm::Equal{} else null endif 
}
context mulOp
def : ast() : as::astm::BinaryExpression =
as::astm::BinaryExpression {
	}
context simpleFactor
def : ast() : as::astm::Expression =
	self.designator.ast()
context factor
def : ast() : as::astm::Expression =
if isANumber()
then as::astm::IntegerLiteral {
	value = number 
}
else
	if isAString()
	then as::astm::StringLiteral {
		value = string 
	}
	else
		if isAFunctionCall()
		then as::astm::DelphiFunctionCallExpression {
			calledFunction = self.designator.ast(), 
		actualParams = expList.createActualParams()
		}
		else 
			invalid
		endif
	endif
endif


endpackage
