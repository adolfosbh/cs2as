source cs : 'generated/Delphi.ecore#/'
target as : 'astm.ecore'

helpers {
	cs::ident {
	    extract() : String := 
	    	null; -- TODO
	}
	
	cs::identList {
	    extract() : String := 
	    	null; -- TODO	
	}
	
	
	cs::designatorPart {
		extract() :String := id
	}

	id
	cs::designator {
		getDefinition() : astm::gastm::Definition :=
			let method = lookup(FunctionDefinition, subpart.part)
			in if method <> null 
			   then method
			   else lookup(VariableDefinition, subpart.part)
			   endif;
		
	}
}
mappings {
	create astm::gastm::Project from mainRule {
		files := file.trace; 
	} 
	create astm::sastm::DelphiUnit from unit {
		name := astm::gastm::Name { nameString = id.extract()};
		language := 'Delphi';
		interface := interfaceSect.trace;
		implementation := implementationSect.trace;
		-- openScope TODO: deals with the scope
		locationInfo := astm::gastm::SourceLocation {
							inSourceFile = astm::gastm::SourceFile {
								-- ISSUE pathName = path
							}};
	}
	create astm::sastm::DelphiInterfaceSection from interfaceSection {
		-- ISSUE uses := uses?.trace;
		fragments := interfaceDecl.trace;
	}
	create astm::sastm::DelphiImplementationSection from implementationSection {
		-- ISSUE uses := uses?.trace;
		-- ISSUE exports := exports.trace;
		fragments := declSect.trace;
	}
	create astm::gastm::LabelDefinition from labelDeclSection {
		-- No additional mappings in Gra2Mol example
	}
	create astm::gastm::VariableDefinition from constantDecl {
		identifierName := astm::gastm::Name { nameString = id.extract() };
		initialValue := const.trace;
	}
	refer as::astm::Expression from ConstExp :=
		exp.trace
	refer as::astm::Expression from MultipleConstExp :=
		exps.trace->first()
	refer as::astm::Expression from RecordConstExp :=
		exps.constExp.trace->first()
	create astm::gastm::TypeDefinition from typeDecl {
		name := astm::gastm::Name { nameString = id.extract() };
	}
	create astm::gastm::VariableDefinition from varDecl  {
		identifierName := astm::gastm::Name { nameString = idList.extract() };
		definitionType := type.trace;
		isMutable := true;
	}
	create astm::gastm::FunctionDefinition from procedureDecl {
		identifierName := astm::gastm::Name{ nameString = heading.id.extract() };
		formalParameters := heading.formalParams?.params?.trace;
		body := block.trace;
	}
	create astm::sastm::DelphiBlockStatement from	block {
		declarations := declSection?.trace;
		subStatements := compound.stamtList.statments.trace;
	}
	refer astm::gastm::Statement from statement :=
		statement.trace; 
	create astm::gastm::ExpressionStatement from assignmentStmnt {
		expression := astm::gastm::BinaryExpression {
						leftOperand = designator.trace,
						operator = astm::gastm::Assign {},
						rightOperand = expression.trace
			};
	}
	create astm::gastm::ExpressionStatement from callStmnt {
		expression := astm::gastm::FunctionCallExpression {
						calledFunction = designator.trace,
						actualParams = args.exps.trace
					};
	}
	create astm::sastm::DelphiWithStatement from withStmt {
		withs := _vars.ids.trace;
		subStatements := stmt.trace;
	}
	create astm::gastm::IfStatement from ifStmt  {
		condition := condition.trace;
		thenBody := _then.trace;
		elseBody := _else.trace;
	}
	
	create astm::gastm::SwitchStatement from caseStmt {
		switchExpression := expression.trace;
		cases            := cases.trace;
	}
	create astm::gastm::CaseBlock from caseSelector {
--		caseExpressions := labels->collect(x | let first = x.first.trace 
--			                                  in if x.last=null 
--			                                     then first  
--			                                     else first->including(x.last.trace)
--			                                     endif);
		caseExpressions := labels->collect(x | x.first.trace->including(x.last?.trace));
		body:= stmt.trace;
	}

	create astm::gastm::TryStatement from tryStmt { 
		guardedStatement := stmtList.statment->first().trace;
		-- ISSUE catchBlocks      := exception.trace;
		finalStatement   := final.statment->first().trace;
	}
	
	create astm::gastm::IdentifierReference from designator 
		when isIdentifierRef {
		name := astm::gastm::Name {
					nameString = subpart.part.extract() 
				};
		refersTo := getDefinition();
		
	}
	create astm::gastm::QualifiedOverData from designator 
		when isQualifiedOverData {
		name := astm::gastm::Name {
					nameString = subpart.part.extract() 
				};
		member := designator.trace.oclAsType(as::IdentifierReference);
		refersTo := getDefinition();
	}
	refer astm::gastm::DefinitionObject from ident :=
		let method = lookup(FunctionDefinition, subpart.part)
		in if method <> null 
		   then method
		   else lookup(VariableDefinition, subpart.part)
		   endif;
	create astm::gastm::BinaryExpression from relExp {
		leftOperand := left.trace;
		rightOperand := right.trace;
		operator := if relOp.op = '=' 
					then astm::gastm::Equal{}
					else null -- other cases missing
					endif;
	}
	create astm::gastm::BinaryExpression from mulOp {
		
	}
	create astm::gastm::IntegerLiteral from factor
		when isANumber {
		value := number;
	}
	create astm::gastm::StringLiteral from factor
		when isAString {
		value := string;
	}
	create astm::gastm::DelphiFunctionCallExpression from factor
		when isAFunctionCall {
		calledFunction := designator.trace;
		actualParams   := expList.exps.trace;
	}
	create astm::gastm::ActualParameterExpression from 	expression {
		value := exp;
	}
}

disambiguation {
	factor {
		isANumber := numer <> null;
		isAString := string <> null;
		isAFunctionCall := expList <> null;
	}
	designator {
		isIdentifierRef := designator = null;
		isQualifiedOverData := designator <> null;
	}
}

name_resolution {
	targets {
		Definition using identifierName;
		VariableDefinition;
		FunctionDefinition;
	}
	
	providers {
		CompilationUnit {
			in current_scope provides
				VariableDefinition using fragments->selectByKind(VariableDefinition)
				FunctionDefinition using fragments->selectByKind(FunctionDefinition);
		}
		
		DelphiBlockStatement {
			in current_scope provides
				VariableDefinition using declarations->selectByKind(VariableDefinition)
				FunctionDefinition using declarations->selectByKind(FunctionDefinition);
		}
	}
}