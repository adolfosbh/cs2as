/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.delphi.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.delphi.delphi.ConstExp;
import org.xtext.example.delphi.delphi.DelphiPackage;
import org.xtext.example.delphi.delphi.MineID;
import org.xtext.example.delphi.delphi.MultipleConstExp;
import org.xtext.example.delphi.delphi.MultipleId;
import org.xtext.example.delphi.delphi.RecordConstExp;
import org.xtext.example.delphi.delphi.ReservedId;
import org.xtext.example.delphi.delphi.adOp;
import org.xtext.example.delphi.delphi.addExp;
import org.xtext.example.delphi.delphi.arrayConstant;
import org.xtext.example.delphi.delphi.arrayType;
import org.xtext.example.delphi.delphi.assemblerStmt;
import org.xtext.example.delphi.delphi.assignmentStmnt;
import org.xtext.example.delphi.delphi.block;
import org.xtext.example.delphi.delphi.callStmnt;
import org.xtext.example.delphi.delphi.caseLabel;
import org.xtext.example.delphi.delphi.caseSelector;
import org.xtext.example.delphi.delphi.caseStmt;
import org.xtext.example.delphi.delphi.classField;
import org.xtext.example.delphi.delphi.classFieldList;
import org.xtext.example.delphi.delphi.classMethod;
import org.xtext.example.delphi.delphi.classMethodList;
import org.xtext.example.delphi.delphi.classProperty;
import org.xtext.example.delphi.delphi.classPropertyList;
import org.xtext.example.delphi.delphi.classRefType;
import org.xtext.example.delphi.delphi.classType;
import org.xtext.example.delphi.delphi.compoundStmt;
import org.xtext.example.delphi.delphi.constSection;
import org.xtext.example.delphi.delphi.constantDecl;
import org.xtext.example.delphi.delphi.constructorHeading;
import org.xtext.example.delphi.delphi.containsClause;
import org.xtext.example.delphi.delphi.designator;
import org.xtext.example.delphi.delphi.designatorPart;
import org.xtext.example.delphi.delphi.designatorSubPart;
import org.xtext.example.delphi.delphi.destructorHeading;
import org.xtext.example.delphi.delphi.directive;
import org.xtext.example.delphi.delphi.enumeratedType;
import org.xtext.example.delphi.delphi.enumeratedTypeElement;
import org.xtext.example.delphi.delphi.exceptionBlock;
import org.xtext.example.delphi.delphi.exportedHeading;
import org.xtext.example.delphi.delphi.exportsItem;
import org.xtext.example.delphi.delphi.exportsStmt;
import org.xtext.example.delphi.delphi.exprList;
import org.xtext.example.delphi.delphi.factor;
import org.xtext.example.delphi.delphi.fieldDecl;
import org.xtext.example.delphi.delphi.fieldList;
import org.xtext.example.delphi.delphi.fileType;
import org.xtext.example.delphi.delphi.forStmt;
import org.xtext.example.delphi.delphi.formalParameters;
import org.xtext.example.delphi.delphi.formalParm;
import org.xtext.example.delphi.delphi.functionDecl;
import org.xtext.example.delphi.delphi.functionHeading;
import org.xtext.example.delphi.delphi.gotoStmnt;
import org.xtext.example.delphi.delphi.identList;
import org.xtext.example.delphi.delphi.ifStmt;
import org.xtext.example.delphi.delphi.implementationSection;
import org.xtext.example.delphi.delphi.inheritedStamnt;
import org.xtext.example.delphi.delphi.initSection;
import org.xtext.example.delphi.delphi.interfaceHeritage;
import org.xtext.example.delphi.delphi.interfaceSection;
import org.xtext.example.delphi.delphi.interfaceType;
import org.xtext.example.delphi.delphi.labelDeclSection;
import org.xtext.example.delphi.delphi.library;
import org.xtext.example.delphi.delphi.mainRule;
import org.xtext.example.delphi.delphi.methodList;
import org.xtext.example.delphi.delphi.mulOp;
import org.xtext.example.delphi.delphi.multExp;
import org.xtext.example.delphi.delphi.objHeritage;
import org.xtext.example.delphi.delphi.objectType;
import org.xtext.example.delphi.delphi.ordIdent;
import org.xtext.example.delphi.delphi.packageDecl;
import org.xtext.example.delphi.delphi.parameterList;
import org.xtext.example.delphi.delphi.parameterSimple;
import org.xtext.example.delphi.delphi.procedureDecl;
import org.xtext.example.delphi.delphi.procedureHeading;
import org.xtext.example.delphi.delphi.procedureType;
import org.xtext.example.delphi.delphi.program;
import org.xtext.example.delphi.delphi.programBlock;
import org.xtext.example.delphi.delphi.propertyInterface;
import org.xtext.example.delphi.delphi.propertyList;
import org.xtext.example.delphi.delphi.propertyParameterList;
import org.xtext.example.delphi.delphi.propertySpecifiers;
import org.xtext.example.delphi.delphi.qualId;
import org.xtext.example.delphi.delphi.raiseStmt;
import org.xtext.example.delphi.delphi.realType;
import org.xtext.example.delphi.delphi.recType;
import org.xtext.example.delphi.delphi.recVariant;
import org.xtext.example.delphi.delphi.recordConstExpr;
import org.xtext.example.delphi.delphi.recordConstant;
import org.xtext.example.delphi.delphi.recordFieldConstant;
import org.xtext.example.delphi.delphi.relExp;
import org.xtext.example.delphi.delphi.relOp;
import org.xtext.example.delphi.delphi.repeatStmt;
import org.xtext.example.delphi.delphi.requiresClause;
import org.xtext.example.delphi.delphi.reservedWord;
import org.xtext.example.delphi.delphi.setConstructor;
import org.xtext.example.delphi.delphi.setElement;
import org.xtext.example.delphi.delphi.setType;
import org.xtext.example.delphi.delphi.simpleFactor;
import org.xtext.example.delphi.delphi.statement;
import org.xtext.example.delphi.delphi.stmtList;
import org.xtext.example.delphi.delphi.stringType;
import org.xtext.example.delphi.delphi.subrangeType;
import org.xtext.example.delphi.delphi.tryStmt;
import org.xtext.example.delphi.delphi.typeDecl;
import org.xtext.example.delphi.delphi.typeId;
import org.xtext.example.delphi.delphi.typeSection;
import org.xtext.example.delphi.delphi.typedConstant;
import org.xtext.example.delphi.delphi.unit;
import org.xtext.example.delphi.delphi.unitId;
import org.xtext.example.delphi.delphi.usesClause;
import org.xtext.example.delphi.delphi.varDecl;
import org.xtext.example.delphi.delphi.varSection;
import org.xtext.example.delphi.delphi.variantSection;
import org.xtext.example.delphi.delphi.variantType;
import org.xtext.example.delphi.delphi.whileStmt;
import org.xtext.example.delphi.delphi.withStmt;
import org.xtext.example.delphi.services.DelphiGrammarAccess;

@SuppressWarnings("all")
public class DelphiSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DelphiGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DelphiPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DelphiPackage.CONST_EXP:
				sequence_constExpr(context, (ConstExp) semanticObject); 
				return; 
			case DelphiPackage.MINE_ID:
				sequence_ident(context, (MineID) semanticObject); 
				return; 
			case DelphiPackage.MULTIPLE_CONST_EXP:
				sequence_constExpr(context, (MultipleConstExp) semanticObject); 
				return; 
			case DelphiPackage.MULTIPLE_ID:
				sequence_ident(context, (MultipleId) semanticObject); 
				return; 
			case DelphiPackage.RECORD_CONST_EXP:
				sequence_constExpr(context, (RecordConstExp) semanticObject); 
				return; 
			case DelphiPackage.RESERVED_ID:
				sequence_ident(context, (ReservedId) semanticObject); 
				return; 
			case DelphiPackage.AD_OP:
				sequence_addOp(context, (adOp) semanticObject); 
				return; 
			case DelphiPackage.ADD_EXP:
				sequence_simpleExpression(context, (addExp) semanticObject); 
				return; 
			case DelphiPackage.ARRAY_CONSTANT:
				sequence_arrayConstant(context, (arrayConstant) semanticObject); 
				return; 
			case DelphiPackage.ARRAY_TYPE:
				sequence_arrayType(context, (arrayType) semanticObject); 
				return; 
			case DelphiPackage.ASSEMBLER_STMT:
				sequence_assemblerStmt(context, (assemblerStmt) semanticObject); 
				return; 
			case DelphiPackage.ASSIGNMENT_STMNT:
				sequence_simpleStatement(context, (assignmentStmnt) semanticObject); 
				return; 
			case DelphiPackage.BLOCK:
				sequence_block(context, (block) semanticObject); 
				return; 
			case DelphiPackage.CALL_STMNT:
				sequence_simpleStatement(context, (callStmnt) semanticObject); 
				return; 
			case DelphiPackage.CASE_LABEL:
				sequence_caseLabel(context, (caseLabel) semanticObject); 
				return; 
			case DelphiPackage.CASE_SELECTOR:
				sequence_caseSelector(context, (caseSelector) semanticObject); 
				return; 
			case DelphiPackage.CASE_STMT:
				sequence_caseStmt(context, (caseStmt) semanticObject); 
				return; 
			case DelphiPackage.CLASS_FIELD:
				sequence_classField(context, (classField) semanticObject); 
				return; 
			case DelphiPackage.CLASS_FIELD_LIST:
				sequence_classFieldList(context, (classFieldList) semanticObject); 
				return; 
			case DelphiPackage.CLASS_METHOD:
				sequence_classMethod(context, (classMethod) semanticObject); 
				return; 
			case DelphiPackage.CLASS_METHOD_LIST:
				sequence_classMethodList(context, (classMethodList) semanticObject); 
				return; 
			case DelphiPackage.CLASS_PROPERTY:
				sequence_classProperty(context, (classProperty) semanticObject); 
				return; 
			case DelphiPackage.CLASS_PROPERTY_LIST:
				sequence_classPropertyList(context, (classPropertyList) semanticObject); 
				return; 
			case DelphiPackage.CLASS_REF_TYPE:
				sequence_classRefType(context, (classRefType) semanticObject); 
				return; 
			case DelphiPackage.CLASS_TYPE:
				sequence_classType(context, (classType) semanticObject); 
				return; 
			case DelphiPackage.COMPOUND_STMT:
				sequence_compoundStmt(context, (compoundStmt) semanticObject); 
				return; 
			case DelphiPackage.CONST_SECTION:
				sequence_constSection(context, (constSection) semanticObject); 
				return; 
			case DelphiPackage.CONSTANT_DECL:
				sequence_constantDecl(context, (constantDecl) semanticObject); 
				return; 
			case DelphiPackage.CONSTRUCTOR_HEADING:
				sequence_constructorHeading(context, (constructorHeading) semanticObject); 
				return; 
			case DelphiPackage.CONTAINS_CLAUSE:
				sequence_containsClause(context, (containsClause) semanticObject); 
				return; 
			case DelphiPackage.DESIGNATOR:
				sequence_designator(context, (designator) semanticObject); 
				return; 
			case DelphiPackage.DESIGNATOR_PART:
				sequence_designatorPart(context, (designatorPart) semanticObject); 
				return; 
			case DelphiPackage.DESIGNATOR_SUB_PART:
				sequence_designatorSubPart(context, (designatorSubPart) semanticObject); 
				return; 
			case DelphiPackage.DESTRUCTOR_HEADING:
				sequence_destructorHeading(context, (destructorHeading) semanticObject); 
				return; 
			case DelphiPackage.DIRECTIVE:
				sequence_directive(context, (directive) semanticObject); 
				return; 
			case DelphiPackage.ENUMERATED_TYPE:
				sequence_enumeratedType(context, (enumeratedType) semanticObject); 
				return; 
			case DelphiPackage.ENUMERATED_TYPE_ELEMENT:
				sequence_enumeratedTypeElement(context, (enumeratedTypeElement) semanticObject); 
				return; 
			case DelphiPackage.EXCEPTION_BLOCK:
				sequence_exceptionBlock(context, (exceptionBlock) semanticObject); 
				return; 
			case DelphiPackage.EXPORTED_HEADING:
				sequence_exportedHeading(context, (exportedHeading) semanticObject); 
				return; 
			case DelphiPackage.EXPORTS_ITEM:
				sequence_exportsItem(context, (exportsItem) semanticObject); 
				return; 
			case DelphiPackage.EXPORTS_STMT:
				sequence_exportsStmt(context, (exportsStmt) semanticObject); 
				return; 
			case DelphiPackage.EXPR_LIST:
				sequence_exprList(context, (exprList) semanticObject); 
				return; 
			case DelphiPackage.FACTOR:
				sequence_factor(context, (factor) semanticObject); 
				return; 
			case DelphiPackage.FIELD_DECL:
				sequence_fieldDecl(context, (fieldDecl) semanticObject); 
				return; 
			case DelphiPackage.FIELD_LIST:
				sequence_fieldList(context, (fieldList) semanticObject); 
				return; 
			case DelphiPackage.FILE_TYPE:
				sequence_fileType(context, (fileType) semanticObject); 
				return; 
			case DelphiPackage.FOR_STMT:
				sequence_forStmt(context, (forStmt) semanticObject); 
				return; 
			case DelphiPackage.FORMAL_PARAMETERS:
				sequence_formalParameters(context, (formalParameters) semanticObject); 
				return; 
			case DelphiPackage.FORMAL_PARM:
				sequence_formalParm(context, (formalParm) semanticObject); 
				return; 
			case DelphiPackage.FUNCTION_DECL:
				sequence_functionDecl(context, (functionDecl) semanticObject); 
				return; 
			case DelphiPackage.FUNCTION_HEADING:
				sequence_functionHeading(context, (functionHeading) semanticObject); 
				return; 
			case DelphiPackage.GOTO_STMNT:
				sequence_simpleStatement(context, (gotoStmnt) semanticObject); 
				return; 
			case DelphiPackage.IDENT_LIST:
				if (rule == grammarAccess.getClassHeritageRule()
						|| rule == grammarAccess.getIdentListRule()) {
					sequence_identList(context, (identList) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getObjFieldListRule()) {
					sequence_identList_objFieldList(context, (identList) semanticObject); 
					return; 
				}
				else break;
			case DelphiPackage.IF_STMT:
				sequence_ifStmt(context, (ifStmt) semanticObject); 
				return; 
			case DelphiPackage.IMPLEMENTATION_SECTION:
				sequence_implementationSection(context, (implementationSection) semanticObject); 
				return; 
			case DelphiPackage.INHERITED_STAMNT:
				sequence_simpleStatement(context, (inheritedStamnt) semanticObject); 
				return; 
			case DelphiPackage.INIT_SECTION:
				sequence_initSection(context, (initSection) semanticObject); 
				return; 
			case DelphiPackage.INTERFACE_HERITAGE:
				sequence_interfaceHeritage(context, (interfaceHeritage) semanticObject); 
				return; 
			case DelphiPackage.INTERFACE_SECTION:
				sequence_interfaceSection(context, (interfaceSection) semanticObject); 
				return; 
			case DelphiPackage.INTERFACE_TYPE:
				sequence_interfaceType(context, (interfaceType) semanticObject); 
				return; 
			case DelphiPackage.LABEL_DECL_SECTION:
				sequence_labelDeclSection(context, (labelDeclSection) semanticObject); 
				return; 
			case DelphiPackage.LIBRARY:
				sequence_library(context, (library) semanticObject); 
				return; 
			case DelphiPackage.MAIN_RULE:
				sequence_mainRule(context, (mainRule) semanticObject); 
				return; 
			case DelphiPackage.METHOD_LIST:
				sequence_methodList(context, (methodList) semanticObject); 
				return; 
			case DelphiPackage.MUL_OP:
				sequence_mulOp(context, (mulOp) semanticObject); 
				return; 
			case DelphiPackage.MULT_EXP:
				sequence_term(context, (multExp) semanticObject); 
				return; 
			case DelphiPackage.OBJ_HERITAGE:
				sequence_objHeritage(context, (objHeritage) semanticObject); 
				return; 
			case DelphiPackage.OBJECT_TYPE:
				sequence_objectType(context, (objectType) semanticObject); 
				return; 
			case DelphiPackage.ORD_IDENT:
				sequence_ordIdent(context, (ordIdent) semanticObject); 
				return; 
			case DelphiPackage.PACKAGE_DECL:
				sequence_packageDecl(context, (packageDecl) semanticObject); 
				return; 
			case DelphiPackage.PARAMETER_LIST:
				sequence_parameter(context, (parameterList) semanticObject); 
				return; 
			case DelphiPackage.PARAMETER_SIMPLE:
				sequence_parameter(context, (parameterSimple) semanticObject); 
				return; 
			case DelphiPackage.PROCEDURE_DECL:
				sequence_procedureDecl(context, (procedureDecl) semanticObject); 
				return; 
			case DelphiPackage.PROCEDURE_HEADING:
				sequence_procedureHeading(context, (procedureHeading) semanticObject); 
				return; 
			case DelphiPackage.PROCEDURE_TYPE:
				sequence_procedureType(context, (procedureType) semanticObject); 
				return; 
			case DelphiPackage.PROGRAM:
				sequence_program(context, (program) semanticObject); 
				return; 
			case DelphiPackage.PROGRAM_BLOCK:
				sequence_programBlock(context, (programBlock) semanticObject); 
				return; 
			case DelphiPackage.PROPERTY_INTERFACE:
				sequence_propertyInterface(context, (propertyInterface) semanticObject); 
				return; 
			case DelphiPackage.PROPERTY_LIST:
				sequence_propertyList(context, (propertyList) semanticObject); 
				return; 
			case DelphiPackage.PROPERTY_PARAMETER_LIST:
				sequence_propertyParameterList(context, (propertyParameterList) semanticObject); 
				return; 
			case DelphiPackage.PROPERTY_SPECIFIERS:
				sequence_propertySpecifiers(context, (propertySpecifiers) semanticObject); 
				return; 
			case DelphiPackage.QUAL_ID:
				sequence_qualId(context, (qualId) semanticObject); 
				return; 
			case DelphiPackage.RAISE_STMT:
				sequence_raiseStmt(context, (raiseStmt) semanticObject); 
				return; 
			case DelphiPackage.REAL_TYPE:
				sequence_realType(context, (realType) semanticObject); 
				return; 
			case DelphiPackage.REC_TYPE:
				sequence_recType(context, (recType) semanticObject); 
				return; 
			case DelphiPackage.REC_VARIANT:
				sequence_recVariant(context, (recVariant) semanticObject); 
				return; 
			case DelphiPackage.RECORD_CONST_EXPR:
				sequence_recordConstExpr(context, (recordConstExpr) semanticObject); 
				return; 
			case DelphiPackage.RECORD_CONSTANT:
				sequence_recordConstant(context, (recordConstant) semanticObject); 
				return; 
			case DelphiPackage.RECORD_FIELD_CONSTANT:
				sequence_recordFieldConstant(context, (recordFieldConstant) semanticObject); 
				return; 
			case DelphiPackage.REL_EXP:
				sequence_expression(context, (relExp) semanticObject); 
				return; 
			case DelphiPackage.REL_OP:
				sequence_relOp(context, (relOp) semanticObject); 
				return; 
			case DelphiPackage.REPEAT_STMT:
				sequence_repeatStmt(context, (repeatStmt) semanticObject); 
				return; 
			case DelphiPackage.REQUIRES_CLAUSE:
				sequence_requiresClause(context, (requiresClause) semanticObject); 
				return; 
			case DelphiPackage.RESERVED_WORD:
				sequence_reservedWord(context, (reservedWord) semanticObject); 
				return; 
			case DelphiPackage.SET_CONSTRUCTOR:
				sequence_setConstructor(context, (setConstructor) semanticObject); 
				return; 
			case DelphiPackage.SET_ELEMENT:
				sequence_setElement(context, (setElement) semanticObject); 
				return; 
			case DelphiPackage.SET_TYPE:
				sequence_setType(context, (setType) semanticObject); 
				return; 
			case DelphiPackage.SIMPLE_FACTOR:
				sequence_factor(context, (simpleFactor) semanticObject); 
				return; 
			case DelphiPackage.STATEMENT:
				sequence_statement(context, (statement) semanticObject); 
				return; 
			case DelphiPackage.STMT_LIST:
				sequence_stmtList(context, (stmtList) semanticObject); 
				return; 
			case DelphiPackage.STRING_TYPE:
				sequence_stringType(context, (stringType) semanticObject); 
				return; 
			case DelphiPackage.SUBRANGE_TYPE:
				sequence_subrangeType(context, (subrangeType) semanticObject); 
				return; 
			case DelphiPackage.TRY_STMT:
				sequence_tryStmt(context, (tryStmt) semanticObject); 
				return; 
			case DelphiPackage.TYPE_DECL:
				sequence_typeDecl(context, (typeDecl) semanticObject); 
				return; 
			case DelphiPackage.TYPE_ID:
				sequence_typeId(context, (typeId) semanticObject); 
				return; 
			case DelphiPackage.TYPE_SECTION:
				sequence_typeSection(context, (typeSection) semanticObject); 
				return; 
			case DelphiPackage.TYPED_CONSTANT:
				sequence_typedConstant(context, (typedConstant) semanticObject); 
				return; 
			case DelphiPackage.UNIT:
				sequence_unit(context, (unit) semanticObject); 
				return; 
			case DelphiPackage.UNIT_ID:
				sequence_unitId(context, (unitId) semanticObject); 
				return; 
			case DelphiPackage.USES_CLAUSE:
				sequence_usesClause(context, (usesClause) semanticObject); 
				return; 
			case DelphiPackage.VAR_DECL:
				sequence_varDecl(context, (varDecl) semanticObject); 
				return; 
			case DelphiPackage.VAR_SECTION:
				sequence_varSection(context, (varSection) semanticObject); 
				return; 
			case DelphiPackage.VARIANT_SECTION:
				sequence_variantSection(context, (variantSection) semanticObject); 
				return; 
			case DelphiPackage.VARIANT_TYPE:
				sequence_variantType(context, (variantType) semanticObject); 
				return; 
			case DelphiPackage.WHILE_STMT:
				sequence_whileStmt(context, (whileStmt) semanticObject); 
				return; 
			case DelphiPackage.WITH_STMT:
				sequence_withStmt(context, (withStmt) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     addOp returns adOp
	 *
	 * Constraint:
	 *     (op='+' | op='-' | op='or' | op='xor')
	 */
	protected void sequence_addOp(ISerializationContext context, adOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     arrayConstant returns arrayConstant
	 *
	 * Constraint:
	 *     typedConstant=typedConstant
	 */
	protected void sequence_arrayConstant(ISerializationContext context, arrayConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ARRAY_CONSTANT__TYPED_CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ARRAY_CONSTANT__TYPED_CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getArrayConstantAccess().getTypedConstantTypedConstantParserRuleCall_1_0(), semanticObject.getTypedConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     type returns arrayType
	 *     strucType returns arrayType
	 *     arrayType returns arrayType
	 *
	 * Constraint:
	 *     ((ordinalType+=ordinalType ordinalTyp+=ordinalType*)? type=type port=portabilityDirective?)
	 */
	protected void sequence_arrayType(ISerializationContext context, arrayType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns assemblerStmt
	 *     structStmt returns assemblerStmt
	 *     assemblerStmt returns assemblerStmt
	 *
	 * Constraint:
	 *     {assemblerStmt}
	 */
	protected void sequence_assemblerStmt(ISerializationContext context, assemblerStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     block returns block
	 *
	 * Constraint:
	 *     (declSect=declSection? exports+=exportsStmt* compound=compoundStmt exports+=exportsStmt*)
	 */
	protected void sequence_block(ISerializationContext context, block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     caseLabel returns caseLabel
	 *
	 * Constraint:
	 *     (first=constExpr last=constExpr?)
	 */
	protected void sequence_caseLabel(ISerializationContext context, caseLabel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     caseSelector returns caseSelector
	 *
	 * Constraint:
	 *     (labels+=caseLabel labels+=caseLabel* stmt=statement)
	 */
	protected void sequence_caseSelector(ISerializationContext context, caseSelector semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns caseStmt
	 *     structStmt returns caseStmt
	 *     conditionalStmt returns caseStmt
	 *     caseStmt returns caseStmt
	 *
	 * Constraint:
	 *     (expression=expression cases+=caseSelector cases+=caseSelector* default=stmtList)
	 */
	protected void sequence_caseStmt(ISerializationContext context, caseStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classFieldList returns classFieldList
	 *
	 * Constraint:
	 *     field+=classField+
	 */
	protected void sequence_classFieldList(ISerializationContext context, classFieldList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classField returns classField
	 *
	 * Constraint:
	 *     (visibility=classVisibility? fieldList=objFieldList)
	 */
	protected void sequence_classField(ISerializationContext context, classField semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classMethodList returns classMethodList
	 *
	 * Constraint:
	 *     metod+=classMethod+
	 */
	protected void sequence_classMethodList(ISerializationContext context, classMethodList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classMethod returns classMethod
	 *
	 * Constraint:
	 *     (visibility=classVisibility? methodList=methodList)
	 */
	protected void sequence_classMethod(ISerializationContext context, classMethod semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classPropertyList returns classPropertyList
	 *
	 * Constraint:
	 *     property+=classProperty+
	 */
	protected void sequence_classPropertyList(ISerializationContext context, classPropertyList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classProperty returns classProperty
	 *
	 * Constraint:
	 *     (visibility=classVisibility | (visibility=classVisibility? propList=propertyList))
	 */
	protected void sequence_classProperty(ISerializationContext context, classProperty semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns classRefType
	 *     classRefType returns classRefType
	 *
	 * Constraint:
	 *     typeRef=typeId
	 */
	protected void sequence_classRefType(ISerializationContext context, classRefType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.CLASS_REF_TYPE__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.CLASS_REF_TYPE__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getClassRefTypeAccess().getTypeRefTypeIdParserRuleCall_2_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     restrictedType returns classType
	 *     classType returns classType
	 *
	 * Constraint:
	 *     (heritage=classHeritage? visibility=classVisibility? fieldList=classFieldList? methodList=classMethodList? propList=classPropertyList?)
	 */
	protected void sequence_classType(ISerializationContext context, classType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns compoundStmt
	 *     structStmt returns compoundStmt
	 *     compoundStmt returns compoundStmt
	 *
	 * Constraint:
	 *     stamtList=stmtList
	 */
	protected void sequence_compoundStmt(ISerializationContext context, compoundStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.COMPOUND_STMT__STAMT_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.COMPOUND_STMT__STAMT_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCompoundStmtAccess().getStamtListStmtListParserRuleCall_1_0(), semanticObject.getStamtList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constExpr returns ConstExp
	 *
	 * Constraint:
	 *     exp=expression
	 */
	protected void sequence_constExpr(ISerializationContext context, ConstExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.CONST_EXP__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.CONST_EXP__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstExprAccess().getExpExpressionParserRuleCall_0_1_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     constExpr returns MultipleConstExp
	 *
	 * Constraint:
	 *     (exps+=constExpr exps+=constExpr*)
	 */
	protected void sequence_constExpr(ISerializationContext context, MultipleConstExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constExpr returns RecordConstExp
	 *
	 * Constraint:
	 *     (exps+=recordConstExpr exps+=recordConstExpr*)
	 */
	protected void sequence_constExpr(ISerializationContext context, RecordConstExp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceDecl returns constSection
	 *     declSection returns constSection
	 *     constSection returns constSection
	 *
	 * Constraint:
	 *     constantDecl+=constantDecl*
	 */
	protected void sequence_constSection(ISerializationContext context, constSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     constantDecl returns constantDecl
	 *
	 * Constraint:
	 *     ((id=ident const=constExpr port=portabilityDirective?) | (id=ident typeRef=typeId typedConstat=typedConstant port=portabilityDirective?))
	 */
	protected void sequence_constantDecl(ISerializationContext context, constantDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     methodHeading returns constructorHeading
	 *     constructorHeading returns constructorHeading
	 *
	 * Constraint:
	 *     (id=ident formalParams=formalParameters?)
	 */
	protected void sequence_constructorHeading(ISerializationContext context, constructorHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     containsClause returns containsClause
	 *
	 * Constraint:
	 *     idList+=identList*
	 */
	protected void sequence_containsClause(ISerializationContext context, containsClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designatorPart returns designatorPart
	 *
	 * Constraint:
	 *     (id=ID | reservedWord=reservedWord | (id=ID id2=ID))
	 */
	protected void sequence_designatorPart(ISerializationContext context, designatorPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designatorSubPart returns designatorSubPart
	 *
	 * Constraint:
	 *     (part=designatorPart exprList+=exprList*)
	 */
	protected void sequence_designatorSubPart(ISerializationContext context, designatorSubPart semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     designator returns designator
	 *
	 * Constraint:
	 *     (subpart=designatorSubPart designator=designator?)
	 */
	protected void sequence_designator(ISerializationContext context, designator semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     methodHeading returns destructorHeading
	 *     destructorHeading returns destructorHeading
	 *
	 * Constraint:
	 *     (id=ident formalParams=formalParameters?)
	 */
	protected void sequence_destructorHeading(ISerializationContext context, destructorHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     directive returns directive
	 *
	 * Constraint:
	 *     (
	 *         dir='cdecl' | 
	 *         dir='register' | 
	 *         dir='dynamic' | 
	 *         dir='virtual' | 
	 *         dir='export' | 
	 *         dir='external' | 
	 *         dir='near' | 
	 *         dir='far' | 
	 *         dir='forward' | 
	 *         (dir='message' messageExp=constExpr) | 
	 *         dir='override' | 
	 *         dir='overload' | 
	 *         dir='pascal' | 
	 *         dir='reintroduce' | 
	 *         dir='safecall' | 
	 *         dir='stdcall' | 
	 *         dir='varargs' | 
	 *         dir='local' | 
	 *         dir='abstract'
	 *     )
	 */
	protected void sequence_directive(ISerializationContext context, directive semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     enumeratedTypeElement returns enumeratedTypeElement
	 *
	 * Constraint:
	 *     (id=ident literalExp=constExpr?)
	 */
	protected void sequence_enumeratedTypeElement(ISerializationContext context, enumeratedTypeElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns enumeratedType
	 *     simpleType returns enumeratedType
	 *     ordinalType returns enumeratedType
	 *     enumeratedType returns enumeratedType
	 *
	 * Constraint:
	 *     element+=enumeratedTypeElement*
	 */
	protected void sequence_enumeratedType(ISerializationContext context, enumeratedType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exceptionBlock returns exceptionBlock
	 *
	 * Constraint:
	 *     ((exceptionId+=ident? type+=type doStmt+=statement)* elseStmts=stmtList?)
	 */
	protected void sequence_exceptionBlock(ISerializationContext context, exceptionBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceDecl returns exportedHeading
	 *     exportedHeading returns exportedHeading
	 *
	 * Constraint:
	 *     ((pHeading=procedureHeading directive=directive?) | (fHeading=functionHeading directive=directive?))
	 */
	protected void sequence_exportedHeading(ISerializationContext context, exportedHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exportsItem returns exportsItem
	 *
	 * Constraint:
	 *     (id=ident constExp+=constExpr? constExp+=constExpr?)
	 */
	protected void sequence_exportsItem(ISerializationContext context, exportsItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exportsStmt returns exportsStmt
	 *
	 * Constraint:
	 *     (items+=exportsItem items+=exportsItem*)
	 */
	protected void sequence_exportsStmt(ISerializationContext context, exportsStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     exprList returns exprList
	 *
	 * Constraint:
	 *     (exps+=expression exps+=expression*)
	 */
	protected void sequence_exprList(ISerializationContext context, exprList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns relExp
	 *     expression.relExp_1_0 returns relExp
	 *
	 * Constraint:
	 *     (left=expression_relExp_1_0 relOp=relOp right=simpleExpression)
	 */
	protected void sequence_expression(ISerializationContext context, relExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.REL_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.REL_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.REL_EXP__REL_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.REL_EXP__REL_OP));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.REL_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.REL_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExpressionAccess().getRelExpLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getExpressionAccess().getRelOpRelOpParserRuleCall_1_1_0(), semanticObject.getRelOp());
		feeder.accept(grammarAccess.getExpressionAccess().getRightSimpleExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns factor
	 *     expression.relExp_1_0 returns factor
	 *     simpleExpression returns factor
	 *     simpleExpression.addExp_2_0 returns factor
	 *     term returns factor
	 *     term.multExp_1_0 returns factor
	 *     factor returns factor
	 *
	 * Constraint:
	 *     (
	 *         (designator=designator expList=exprList) | 
	 *         number=number | 
	 *         string=string | 
	 *         nestedExp=expression | 
	 *         exp=factor | 
	 *         setConstuctor=setConstructor | 
	 *         (typeRef=typeId exp=expression)
	 *     )?
	 */
	protected void sequence_factor(ISerializationContext context, factor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns simpleFactor
	 *     expression.relExp_1_0 returns simpleFactor
	 *     simpleExpression returns simpleFactor
	 *     simpleExpression.addExp_2_0 returns simpleFactor
	 *     term returns simpleFactor
	 *     term.multExp_1_0 returns simpleFactor
	 *     factor returns simpleFactor
	 *
	 * Constraint:
	 *     (designator=designator | designator=designator)
	 */
	protected void sequence_factor(ISerializationContext context, simpleFactor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldDecl returns fieldDecl
	 *
	 * Constraint:
	 *     (idList=identList type=type port=portabilityDirective?)
	 */
	protected void sequence_fieldDecl(ISerializationContext context, fieldDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     fieldList returns fieldList
	 *
	 * Constraint:
	 *     (field+=fieldDecl+ variantSect=variantSection?)
	 */
	protected void sequence_fieldList(ISerializationContext context, fieldList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns fileType
	 *     strucType returns fileType
	 *     fileType returns fileType
	 *
	 * Constraint:
	 *     (typeRef=typeId port=portabilityDirective?)
	 */
	protected void sequence_fileType(ISerializationContext context, fileType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns forStmt
	 *     structStmt returns forStmt
	 *     loopStmt returns forStmt
	 *     forStmt returns forStmt
	 *
	 * Constraint:
	 *     (varId=qualId varInit=expression condition=expression stmt=statement)
	 */
	protected void sequence_forStmt(ISerializationContext context, forStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.FOR_STMT__VAR_ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.FOR_STMT__VAR_ID));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.FOR_STMT__VAR_INIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.FOR_STMT__VAR_INIT));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStmtAccess().getVarIdQualIdParserRuleCall_1_0(), semanticObject.getVarId());
		feeder.accept(grammarAccess.getForStmtAccess().getVarInitExpressionParserRuleCall_3_0(), semanticObject.getVarInit());
		feeder.accept(grammarAccess.getForStmtAccess().getConditionExpressionParserRuleCall_5_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getForStmtAccess().getStmtStatementParserRuleCall_7_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     formalParameters returns formalParameters
	 *
	 * Constraint:
	 *     (params+=formalParm params+=formalParm*)
	 */
	protected void sequence_formalParameters(ISerializationContext context, formalParameters semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     formalParm returns formalParm
	 *
	 * Constraint:
	 *     param=parameter
	 */
	protected void sequence_formalParm(ISerializationContext context, formalParm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.FORMAL_PARM__PARAM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.FORMAL_PARM__PARAM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFormalParmAccess().getParamParameterParserRuleCall_1_0(), semanticObject.getParam());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declSection returns functionDecl
	 *     procedureDeclSection returns functionDecl
	 *     functionDecl returns functionDecl
	 *
	 * Constraint:
	 *     (heading=functionHeading directive=directive? port=portabilityDirective? block=block)
	 */
	protected void sequence_functionDecl(ISerializationContext context, functionDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     functionHeading returns functionHeading
	 *     methodHeading returns functionHeading
	 *
	 * Constraint:
	 *     (id=ident formalParams=formalParameters? type=type)
	 */
	protected void sequence_functionHeading(ISerializationContext context, functionHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     classHeritage returns identList
	 *     identList returns identList
	 *
	 * Constraint:
	 *     (ids+=ident ids+=ident*)
	 */
	protected void sequence_identList(ISerializationContext context, identList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     objFieldList returns identList
	 *
	 * Constraint:
	 *     (ids+=ident ids+=ident* type=type)
	 */
	protected void sequence_identList_objFieldList(ISerializationContext context, identList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ident returns MineID
	 *
	 * Constraint:
	 *     (first=ID second=ID)
	 */
	protected void sequence_ident(ISerializationContext context, MineID semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MINE_ID__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MINE_ID__FIRST));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MINE_ID__SECOND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MINE_ID__SECOND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentAccess().getFirstIDTerminalRuleCall_2_1_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getIdentAccess().getSecondIDTerminalRuleCall_2_3_0(), semanticObject.getSecond());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ident returns MultipleId
	 *
	 * Constraint:
	 *     (id+=ID id+=ID*)
	 */
	protected void sequence_ident(ISerializationContext context, MultipleId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ident returns ReservedId
	 *
	 * Constraint:
	 *     reservedWord=reservedWord
	 */
	protected void sequence_ident(ISerializationContext context, ReservedId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RESERVED_ID__RESERVED_WORD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RESERVED_ID__RESERVED_WORD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIdentAccess().getReservedWordReservedWordParserRuleCall_1_2_0(), semanticObject.getReservedWord());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns ifStmt
	 *     structStmt returns ifStmt
	 *     conditionalStmt returns ifStmt
	 *     ifStmt returns ifStmt
	 *
	 * Constraint:
	 *     (condition=expression then=statement else=statement?)
	 */
	protected void sequence_ifStmt(ISerializationContext context, ifStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     implementationSection returns implementationSection
	 *
	 * Constraint:
	 *     (uses=usesClause? declSect+=declSection* exports+=exportsStmt*)
	 */
	protected void sequence_implementationSection(ISerializationContext context, implementationSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     initSection returns initSection
	 *
	 * Constraint:
	 *     ((stmtList=stmtList endStmtList=stmtList?) | stmtList=stmtList)?
	 */
	protected void sequence_initSection(ISerializationContext context, initSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceHeritage returns interfaceHeritage
	 *
	 * Constraint:
	 *     idList=identList
	 */
	protected void sequence_interfaceHeritage(ISerializationContext context, interfaceHeritage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.INTERFACE_HERITAGE__ID_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.INTERFACE_HERITAGE__ID_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInterfaceHeritageAccess().getIdListIdentListParserRuleCall_1_0(), semanticObject.getIdList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     interfaceSection returns interfaceSection
	 *
	 * Constraint:
	 *     (uses=usesClause? interfaceDecl+=interfaceDecl*)
	 */
	protected void sequence_interfaceSection(ISerializationContext context, interfaceSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     restrictedType returns interfaceType
	 *     interfaceType returns interfaceType
	 *
	 * Constraint:
	 *     (heritage=interfaceHeritage methodList=classMethodList propList+=classPropertyList*)
	 */
	protected void sequence_interfaceType(ISerializationContext context, interfaceType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     declSection returns labelDeclSection
	 *     labelDeclSection returns labelDeclSection
	 *
	 * Constraint:
	 *     id=labelId
	 */
	protected void sequence_labelDeclSection(ISerializationContext context, labelDeclSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LABEL_DECL_SECTION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LABEL_DECL_SECTION__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLabelDeclSectionAccess().getIdLabelIdParserRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     file returns library
	 *     library returns library
	 *
	 * Constraint:
	 *     (id=ident pBlock=programBlock)
	 */
	protected void sequence_library(ISerializationContext context, library semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.FILE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.FILE__ID));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LIBRARY__PBLOCK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LIBRARY__PBLOCK));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLibraryAccess().getIdIdentParserRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getLibraryAccess().getPBlockProgramBlockParserRuleCall_3_0(), semanticObject.getPBlock());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     mainRule returns mainRule
	 *
	 * Constraint:
	 *     file=file
	 */
	protected void sequence_mainRule(ISerializationContext context, mainRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MAIN_RULE__FILE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MAIN_RULE__FILE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMainRuleAccess().getFileFileParserRuleCall_0(), semanticObject.getFile());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     methodList returns methodList
	 *
	 * Constraint:
	 *     (heading=methodHeading directive+=directive*)
	 */
	protected void sequence_methodList(ISerializationContext context, methodList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     mulOp returns mulOp
	 *
	 * Constraint:
	 *     (
	 *         op='*' | 
	 *         op='/' | 
	 *         op='div' | 
	 *         op='mod' | 
	 *         op='and' | 
	 *         op='shl' | 
	 *         op='shr'
	 *     )
	 */
	protected void sequence_mulOp(ISerializationContext context, mulOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     objHeritage returns objHeritage
	 *
	 * Constraint:
	 *     id=qualId
	 */
	protected void sequence_objHeritage(ISerializationContext context, objHeritage semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.OBJ_HERITAGE__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.OBJ_HERITAGE__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getObjHeritageAccess().getIdQualIdParserRuleCall_1_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     restrictedType returns objectType
	 *     objectType returns objectType
	 *
	 * Constraint:
	 *     (heritage=objHeritage? fieldList=objFieldList? methodList=methodList?)
	 */
	protected void sequence_objectType(ISerializationContext context, objectType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns ordIdent
	 *     simpleType returns ordIdent
	 *     ordinalType returns ordIdent
	 *     ordIdent returns ordIdent
	 *
	 * Constraint:
	 *     {ordIdent}
	 */
	protected void sequence_ordIdent(ISerializationContext context, ordIdent semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     file returns packageDecl
	 *     packageDecl returns packageDecl
	 *
	 * Constraint:
	 *     (id=ident requires=requiresClause? contains=containsClause?)
	 */
	protected void sequence_packageDecl(ISerializationContext context, packageDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter returns parameterList
	 *
	 * Constraint:
	 *     (idList=identList type=type?)
	 */
	protected void sequence_parameter(ISerializationContext context, parameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     parameter returns parameterSimple
	 *
	 * Constraint:
	 *     (if=ident type=type initExp=constExpr)
	 */
	protected void sequence_parameter(ISerializationContext context, parameterSimple semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.PARAMETER_SIMPLE__IF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.PARAMETER_SIMPLE__IF));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.PARAMETER__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.PARAMETER__TYPE));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.PARAMETER_SIMPLE__INIT_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.PARAMETER_SIMPLE__INIT_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getIfIdentParserRuleCall_1_1_0(), semanticObject.getIf());
		feeder.accept(grammarAccess.getParameterAccess().getTypeTypeParserRuleCall_1_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterAccess().getInitExpConstExprParserRuleCall_1_5_0(), semanticObject.getInitExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     declSection returns procedureDecl
	 *     procedureDeclSection returns procedureDecl
	 *     procedureDecl returns procedureDecl
	 *
	 * Constraint:
	 *     (heading=procedureHeading directive=directive? port=portabilityDirective? block=block)
	 */
	protected void sequence_procedureDecl(ISerializationContext context, procedureDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     procedureHeading returns procedureHeading
	 *     methodHeading returns procedureHeading
	 *
	 * Constraint:
	 *     (id=ident formalParams=formalParameters?)
	 */
	protected void sequence_procedureHeading(ISerializationContext context, procedureHeading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns procedureType
	 *     procedureType returns procedureType
	 *
	 * Constraint:
	 *     (pHeading=procedureHeading | fHeading=functionHeading)
	 */
	protected void sequence_procedureType(ISerializationContext context, procedureType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     programBlock returns programBlock
	 *
	 * Constraint:
	 *     (uses=usesClause? block=block)
	 */
	protected void sequence_programBlock(ISerializationContext context, programBlock semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     file returns program
	 *     program returns program
	 *
	 * Constraint:
	 *     ((id=ident paramsList=identList?)? block=programBlock)
	 */
	protected void sequence_program(ISerializationContext context, program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     propertyInterface returns propertyInterface
	 *
	 * Constraint:
	 *     (paramList=propertyParameterList? id=ident)
	 */
	protected void sequence_propertyInterface(ISerializationContext context, propertyInterface semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     propertyList returns propertyList
	 *
	 * Constraint:
	 *     (id=ident interface=propertyInterface? specifiers=propertySpecifiers? port=portabilityDirective?)
	 */
	protected void sequence_propertyList(ISerializationContext context, propertyList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     propertyParameterList returns propertyParameterList
	 *
	 * Constraint:
	 *     (idList+=identList typeRef+=typeId (idList+=identList typeRef+=typeId)*)
	 */
	protected void sequence_propertyParameterList(ISerializationContext context, propertyParameterList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     propertySpecifiers returns propertySpecifiers
	 *
	 * Constraint:
	 *     (
	 *         index=constExpr? 
	 *         readId=ident? 
	 *         writeId=ident? 
	 *         (storeId=ident | storeExp=constExpr)? 
	 *         defaulExp=constExpr? 
	 *         implement=typeId?
	 *     )
	 */
	protected void sequence_propertySpecifiers(ISerializationContext context, propertySpecifiers semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     qualId returns qualId
	 *
	 * Constraint:
	 *     (unitId=unitId? id=ident)
	 */
	protected void sequence_qualId(ISerializationContext context, qualId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns raiseStmt
	 *     structStmt returns raiseStmt
	 *     raiseStmt returns raiseStmt
	 *
	 * Constraint:
	 *     (raise=ID? at=ID?)
	 */
	protected void sequence_raiseStmt(ISerializationContext context, raiseStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns realType
	 *     simpleType returns realType
	 *     realType returns realType
	 *
	 * Constraint:
	 *     {realType}
	 */
	protected void sequence_realType(ISerializationContext context, realType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns recType
	 *     strucType returns recType
	 *     recType returns recType
	 *
	 * Constraint:
	 *     (fields=fieldList? port=portabilityDirective?)
	 */
	protected void sequence_recType(ISerializationContext context, recType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recVariant returns recVariant
	 *
	 * Constraint:
	 *     (constExp+=constExpr constExp+=constExpr+ fieldList=fieldList)
	 */
	protected void sequence_recVariant(ISerializationContext context, recVariant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recordConstExpr returns recordConstExpr
	 *
	 * Constraint:
	 *     (id=ident constExp=constExpr)
	 */
	protected void sequence_recordConstExpr(ISerializationContext context, recordConstExpr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RECORD_CONST_EXPR__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RECORD_CONST_EXPR__ID));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RECORD_CONST_EXPR__CONST_EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RECORD_CONST_EXPR__CONST_EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordConstExprAccess().getIdIdentParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getRecordConstExprAccess().getConstExpConstExprParserRuleCall_2_0(), semanticObject.getConstExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     recordConstant returns recordConstant
	 *
	 * Constraint:
	 *     recordField+=recordFieldConstant*
	 */
	protected void sequence_recordConstant(ISerializationContext context, recordConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     recordFieldConstant returns recordFieldConstant
	 *
	 * Constraint:
	 *     (id=ident typedConstant=typedConstant)
	 */
	protected void sequence_recordFieldConstant(ISerializationContext context, recordFieldConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RECORD_FIELD_CONSTANT__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RECORD_FIELD_CONSTANT__ID));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RECORD_FIELD_CONSTANT__TYPED_CONSTANT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RECORD_FIELD_CONSTANT__TYPED_CONSTANT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRecordFieldConstantAccess().getIdIdentParserRuleCall_0_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getRecordFieldConstantAccess().getTypedConstantTypedConstantParserRuleCall_2_0(), semanticObject.getTypedConstant());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     relOp returns relOp
	 *
	 * Constraint:
	 *     (
	 *         op='=' | 
	 *         op='>' | 
	 *         op='<' | 
	 *         op='<=' | 
	 *         op='>=' | 
	 *         op='<>' | 
	 *         op='in' | 
	 *         op='is' | 
	 *         op='as'
	 *     )
	 */
	protected void sequence_relOp(ISerializationContext context, relOp semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns repeatStmt
	 *     structStmt returns repeatStmt
	 *     loopStmt returns repeatStmt
	 *     repeatStmt returns repeatStmt
	 *
	 * Constraint:
	 *     (stmt=statement condition=expression)
	 */
	protected void sequence_repeatStmt(ISerializationContext context, repeatStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRepeatStmtAccess().getStmtStatementParserRuleCall_1_0(), semanticObject.getStmt());
		feeder.accept(grammarAccess.getRepeatStmtAccess().getConditionExpressionParserRuleCall_4_0(), semanticObject.getCondition());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     requiresClause returns requiresClause
	 *
	 * Constraint:
	 *     idList+=identList*
	 */
	protected void sequence_requiresClause(ISerializationContext context, requiresClause semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     reservedWord returns reservedWord
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_reservedWord(ISerializationContext context, reservedWord semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.RESERVED_WORD__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.RESERVED_WORD__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getReservedWordAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     setConstructor returns setConstructor
	 *
	 * Constraint:
	 *     (element+=setElement element+=setElement*)
	 */
	protected void sequence_setConstructor(ISerializationContext context, setConstructor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     setElement returns setElement
	 *
	 * Constraint:
	 *     (first=expression last=expression?)
	 */
	protected void sequence_setElement(ISerializationContext context, setElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns setType
	 *     strucType returns setType
	 *     setType returns setType
	 *
	 * Constraint:
	 *     (ordinal=ordinalType port=portabilityDirective?)
	 */
	protected void sequence_setType(ISerializationContext context, setType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     expression returns addExp
	 *     expression.relExp_1_0 returns addExp
	 *     simpleExpression returns addExp
	 *     simpleExpression.addExp_2_0 returns addExp
	 *
	 * Constraint:
	 *     (left=simpleExpression_addExp_2_0 addOp=addOp right=term)
	 */
	protected void sequence_simpleExpression(ISerializationContext context, addExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ADD_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ADD_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ADD_EXP__ADD_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ADD_EXP__ADD_OP));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ADD_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ADD_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getAddExpLeftAction_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getAddOpAddOpParserRuleCall_2_1_0(), semanticObject.getAddOp());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getRightTermParserRuleCall_2_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns assignmentStmnt
	 *     simpleStatement returns assignmentStmnt
	 *
	 * Constraint:
	 *     (designator=designator operator=':=' exp=expression)
	 */
	protected void sequence_simpleStatement(ISerializationContext context, assignmentStmnt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__DESIGNATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__DESIGNATOR));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.ASSIGNMENT_STMNT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getDesignatorDesignatorParserRuleCall_0_1_0(), semanticObject.getDesignator());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getOperatorColonEqualsSignKeyword_0_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getSimpleStatementAccess().getExpExpressionParserRuleCall_0_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns callStmnt
	 *     simpleStatement returns callStmnt
	 *
	 * Constraint:
	 *     (designator=designator args=exprList?)
	 */
	protected void sequence_simpleStatement(ISerializationContext context, callStmnt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns gotoStmnt
	 *     simpleStatement returns gotoStmnt
	 *
	 * Constraint:
	 *     label=labelId
	 */
	protected void sequence_simpleStatement(ISerializationContext context, gotoStmnt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.GOTO_STMNT__LABEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.GOTO_STMNT__LABEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleStatementAccess().getLabelLabelIdParserRuleCall_3_2_0(), semanticObject.getLabel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns inheritedStamnt
	 *     simpleStatement returns inheritedStamnt
	 *
	 * Constraint:
	 *     {inheritedStamnt}
	 */
	protected void sequence_simpleStatement(ISerializationContext context, inheritedStamnt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     statement returns statement
	 *
	 * Constraint:
	 *     (labelId=labelId? statement=unlabelledStatement)
	 */
	protected void sequence_statement(ISerializationContext context, statement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     stmtList returns stmtList
	 *
	 * Constraint:
	 *     statments+=statement*
	 */
	protected void sequence_stmtList(ISerializationContext context, stmtList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns stringType
	 *     stringType returns stringType
	 *
	 * Constraint:
	 *     constExp=constExpr?
	 */
	protected void sequence_stringType(ISerializationContext context, stringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns subrangeType
	 *     simpleType returns subrangeType
	 *     ordinalType returns subrangeType
	 *     subrangeType returns subrangeType
	 *
	 * Constraint:
	 *     (first=constExpr last=constExpr)
	 */
	protected void sequence_subrangeType(ISerializationContext context, subrangeType semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.SUBRANGE_TYPE__FIRST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.SUBRANGE_TYPE__FIRST));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.SUBRANGE_TYPE__LAST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.SUBRANGE_TYPE__LAST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getFirstConstExprParserRuleCall_0_0(), semanticObject.getFirst());
		feeder.accept(grammarAccess.getSubrangeTypeAccess().getLastConstExprParserRuleCall_2_0(), semanticObject.getLast());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     expression returns multExp
	 *     expression.relExp_1_0 returns multExp
	 *     simpleExpression returns multExp
	 *     simpleExpression.addExp_2_0 returns multExp
	 *     term returns multExp
	 *     term.multExp_1_0 returns multExp
	 *
	 * Constraint:
	 *     (left=term_multExp_1_0 multOp=mulOp right=factor)
	 */
	protected void sequence_term(ISerializationContext context, multExp semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MULT_EXP__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MULT_EXP__LEFT));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MULT_EXP__MULT_OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MULT_EXP__MULT_OP));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.MULT_EXP__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.MULT_EXP__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTermAccess().getMultExpLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTermAccess().getMultOpMulOpParserRuleCall_1_1_0(), semanticObject.getMultOp());
		feeder.accept(grammarAccess.getTermAccess().getRightFactorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns tryStmt
	 *     structStmt returns tryStmt
	 *     tryStmt returns tryStmt
	 *
	 * Constraint:
	 *     (stmtList=stmtList (exception=exceptionBlock | final=stmtList))
	 */
	protected void sequence_tryStmt(ISerializationContext context, tryStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typeDecl returns typeDecl
	 *
	 * Constraint:
	 *     ((id=ident type=type port=portabilityDirective?) | (id=ident restrictedType=restrictedType port=portabilityDirective?))
	 */
	protected void sequence_typeDecl(ISerializationContext context, typeDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns typeId
	 *     pointerType returns typeId
	 *     typeId returns typeId
	 *
	 * Constraint:
	 *     (unitId=unitId? id=qualId)
	 */
	protected void sequence_typeId(ISerializationContext context, typeId semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceDecl returns typeSection
	 *     declSection returns typeSection
	 *     typeSection returns typeSection
	 *
	 * Constraint:
	 *     typeDecl+=typeDecl*
	 */
	protected void sequence_typeSection(ISerializationContext context, typeSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     typedConstant returns typedConstant
	 *
	 * Constraint:
	 *     (const=constExpr | array=arrayConstant | record=recordConstant)
	 */
	protected void sequence_typedConstant(ISerializationContext context, typedConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unitId returns unitId
	 *
	 * Constraint:
	 *     id=ID
	 */
	protected void sequence_unitId(ISerializationContext context, unitId semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.UNIT_ID__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.UNIT_ID__ID));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnitIdAccess().getIdIDTerminalRuleCall_0(), semanticObject.getId());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     file returns unit
	 *     unit returns unit
	 *
	 * Constraint:
	 *     (id=ident port=portabilityDirective? interfaceSect=interfaceSection implementationSect=implementationSection initSect=initSection)
	 */
	protected void sequence_unit(ISerializationContext context, unit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     usesClause returns usesClause
	 *
	 * Constraint:
	 *     idList=identList
	 */
	protected void sequence_usesClause(ISerializationContext context, usesClause semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.USES_CLAUSE__ID_LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.USES_CLAUSE__ID_LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUsesClauseAccess().getIdListIdentListParserRuleCall_1_0(), semanticObject.getIdList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     varDecl returns varDecl
	 *
	 * Constraint:
	 *     (idList=identList type=type (absId=ident | absConst=constExpr | absIniti=constExpr)?)
	 */
	protected void sequence_varDecl(ISerializationContext context, varDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     interfaceDecl returns varSection
	 *     declSection returns varSection
	 *     varSection returns varSection
	 *
	 * Constraint:
	 *     varDecls+=varDecl+
	 */
	protected void sequence_varSection(ISerializationContext context, varSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     variantSection returns variantSection
	 *
	 * Constraint:
	 *     (id=ident? typeRef=typeId recVariants+=recVariant+)
	 */
	protected void sequence_variantSection(ISerializationContext context, variantSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     type returns variantType
	 *     variantType returns variantType
	 *
	 * Constraint:
	 *     {variantType}
	 */
	protected void sequence_variantType(ISerializationContext context, variantType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns whileStmt
	 *     structStmt returns whileStmt
	 *     loopStmt returns whileStmt
	 *     whileStmt returns whileStmt
	 *
	 * Constraint:
	 *     (condition=expression stmt=statement)
	 */
	protected void sequence_whileStmt(ISerializationContext context, whileStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.LOOP_STMT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStmtAccess().getConditionExpressionParserRuleCall_1_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStmtAccess().getStmtStatementParserRuleCall_3_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     unlabelledStatement returns withStmt
	 *     structStmt returns withStmt
	 *     withStmt returns withStmt
	 *
	 * Constraint:
	 *     (vars=identList stmt=statement)
	 */
	protected void sequence_withStmt(ISerializationContext context, withStmt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.WITH_STMT__VARS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.WITH_STMT__VARS));
			if (transientValues.isValueTransient(semanticObject, DelphiPackage.Literals.WITH_STMT__STMT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DelphiPackage.Literals.WITH_STMT__STMT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWithStmtAccess().getVarsIdentListParserRuleCall_1_0(), semanticObject.getVars());
		feeder.accept(grammarAccess.getWithStmtAccess().getStmtStatementParserRuleCall_3_0(), semanticObject.getStmt());
		feeder.finish();
	}
	
	
}
