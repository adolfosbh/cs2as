/*
 * generated by Xtext 2.10.0-SNAPSHOT
 */
package uk.ac.york.cs.miniocl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import uk.ac.york.cs.miniocl.miniOCL.BooleanExpCS;
import uk.ac.york.cs.miniocl.miniOCL.CallExpCS;
import uk.ac.york.cs.miniocl.miniOCL.ClassCS;
import uk.ac.york.cs.miniocl.miniOCL.ConstraintCS;
import uk.ac.york.cs.miniocl.miniOCL.IntLiteralExpCS;
import uk.ac.york.cs.miniocl.miniOCL.InvariantCS;
import uk.ac.york.cs.miniocl.miniOCL.LogicExpCS;
import uk.ac.york.cs.miniocl.miniOCL.MiniOCLPackage;
import uk.ac.york.cs.miniocl.miniOCL.NameExpCS;
import uk.ac.york.cs.miniocl.miniOCL.OperationCS;
import uk.ac.york.cs.miniocl.miniOCL.PackageCS;
import uk.ac.york.cs.miniocl.miniOCL.ParameterCS;
import uk.ac.york.cs.miniocl.miniOCL.PathElementCS;
import uk.ac.york.cs.miniocl.miniOCL.PathNameCS;
import uk.ac.york.cs.miniocl.miniOCL.PropertyCS;
import uk.ac.york.cs.miniocl.miniOCL.RootCS;
import uk.ac.york.cs.miniocl.miniOCL.RoundedBracketClauseCS;
import uk.ac.york.cs.miniocl.miniOCL.StringLiteralExpCS;
import uk.ac.york.cs.miniocl.services.MiniOCLGrammarAccess;

@SuppressWarnings("all")
public class MiniOCLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MiniOCLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MiniOCLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MiniOCLPackage.BOOLEAN_EXP_CS:
				sequence_BooleanLiteralExpCS(context, (BooleanExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.CALL_EXP_CS:
				sequence_CallExpCS(context, (CallExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.CLASS_CS:
				sequence_ClassCS(context, (ClassCS) semanticObject); 
				return; 
			case MiniOCLPackage.CONSTRAINT_CS:
				sequence_ConstraintCS(context, (ConstraintCS) semanticObject); 
				return; 
			case MiniOCLPackage.INT_LITERAL_EXP_CS:
				sequence_IntLiteralExpCS(context, (IntLiteralExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.INVARIANT_CS:
				sequence_InvariantCS(context, (InvariantCS) semanticObject); 
				return; 
			case MiniOCLPackage.LOGIC_EXP_CS:
				sequence_LogicExpCS(context, (LogicExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.NAME_EXP_CS:
				sequence_NameExpCS(context, (NameExpCS) semanticObject); 
				return; 
			case MiniOCLPackage.OPERATION_CS:
				sequence_OperationCS(context, (OperationCS) semanticObject); 
				return; 
			case MiniOCLPackage.PACKAGE_CS:
				sequence_PackageCS(context, (PackageCS) semanticObject); 
				return; 
			case MiniOCLPackage.PARAMETER_CS:
				sequence_ParameterCS(context, (ParameterCS) semanticObject); 
				return; 
			case MiniOCLPackage.PATH_ELEMENT_CS:
				sequence_PathElementCS(context, (PathElementCS) semanticObject); 
				return; 
			case MiniOCLPackage.PATH_NAME_CS:
				sequence_PathNameCS(context, (PathNameCS) semanticObject); 
				return; 
			case MiniOCLPackage.PROPERTY_CS:
				sequence_PropertyCS(context, (PropertyCS) semanticObject); 
				return; 
			case MiniOCLPackage.ROOT_CS:
				sequence_RootCS(context, (RootCS) semanticObject); 
				return; 
			case MiniOCLPackage.ROUNDED_BRACKET_CLAUSE_CS:
				sequence_RoundedBracketClauseCS(context, (RoundedBracketClauseCS) semanticObject); 
				return; 
			case MiniOCLPackage.STRING_LITERAL_EXP_CS:
				sequence_StringLiteralExpCS(context, (StringLiteralExpCS) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ExpCS returns BooleanExpCS
	 *     LogicExpCS returns BooleanExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns BooleanExpCS
	 *     CallExpCS returns BooleanExpCS
	 *     CallExpCS.CallExpCS_1_0 returns BooleanExpCS
	 *     PrimaryExpCS returns BooleanExpCS
	 *     LiteralExpCS returns BooleanExpCS
	 *     BooleanLiteralExpCS returns BooleanExpCS
	 *
	 * Constraint:
	 *     boolSymbol?='true'?
	 */
	protected void sequence_BooleanLiteralExpCS(ISerializationContext context, BooleanExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns CallExpCS
	 *     LogicExpCS returns CallExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns CallExpCS
	 *     CallExpCS returns CallExpCS
	 *     CallExpCS.CallExpCS_1_0 returns CallExpCS
	 *
	 * Constraint:
	 *     (source=CallExpCS_CallExpCS_1_0 (op='.' | op='->') nameExp=NameExpCS)
	 */
	protected void sequence_CallExpCS(ISerializationContext context, CallExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ClassCS returns ClassCS
	 *
	 * Constraint:
	 *     (name=ID extends=PathNameCS? (properties+=PropertyCS | operations+=OperationCS)*)
	 */
	protected void sequence_ClassCS(ISerializationContext context, ClassCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstraintCS returns ConstraintCS
	 *
	 * Constraint:
	 *     (typeRef=PathNameCS invariants+=InvariantCS*)
	 */
	protected void sequence_ConstraintCS(ISerializationContext context, ConstraintCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns IntLiteralExpCS
	 *     LogicExpCS returns IntLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns IntLiteralExpCS
	 *     CallExpCS returns IntLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns IntLiteralExpCS
	 *     PrimaryExpCS returns IntLiteralExpCS
	 *     LiteralExpCS returns IntLiteralExpCS
	 *     IntLiteralExpCS returns IntLiteralExpCS
	 *
	 * Constraint:
	 *     intSymbol=INT
	 */
	protected void sequence_IntLiteralExpCS(ISerializationContext context, IntLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.INT_LITERAL_EXP_CS__INT_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralExpCSAccess().getIntSymbolINTTerminalRuleCall_0(), semanticObject.getIntSymbol());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InvariantCS returns InvariantCS
	 *
	 * Constraint:
	 *     exp=ExpCS
	 */
	protected void sequence_InvariantCS(ISerializationContext context, InvariantCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.INVARIANT_CS__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.INVARIANT_CS__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInvariantCSAccess().getExpExpCSParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns LogicExpCS
	 *     LogicExpCS returns LogicExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns LogicExpCS
	 *
	 * Constraint:
	 *     (left=LogicExpCS_LogicExpCS_1_0 (op='=' | op='<>') right=CallExpCS)
	 */
	protected void sequence_LogicExpCS(ISerializationContext context, LogicExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns NameExpCS
	 *     LogicExpCS returns NameExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns NameExpCS
	 *     CallExpCS returns NameExpCS
	 *     CallExpCS.CallExpCS_1_0 returns NameExpCS
	 *     PrimaryExpCS returns NameExpCS
	 *     NameExpCS returns NameExpCS
	 *
	 * Constraint:
	 *     (expName=PathNameCS roundedBrackets=RoundedBracketClauseCS? callExp=CallExpCS?)
	 */
	protected void sequence_NameExpCS(ISerializationContext context, NameExpCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OperationCS returns OperationCS
	 *
	 * Constraint:
	 *     (name=ID (params+=ParameterCS params+=ParameterCS*)? resultRef=PathNameCS body=ExpCS)
	 */
	protected void sequence_OperationCS(ISerializationContext context, OperationCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PackageCS returns PackageCS
	 *
	 * Constraint:
	 *     (name=ID (packages+=PackageCS | classes+=ClassCS)*)
	 */
	protected void sequence_PackageCS(ISerializationContext context, PackageCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ParameterCS returns ParameterCS
	 *
	 * Constraint:
	 *     (name=ID typeRef=PathNameCS)
	 */
	protected void sequence_ParameterCS(ISerializationContext context, ParameterCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PARAMETER_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PARAMETER_CS__NAME));
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PARAMETER_CS__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PARAMETER_CS__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterCSAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterCSAccess().getTypeRefPathNameCSParserRuleCall_2_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathElementCS returns PathElementCS
	 *
	 * Constraint:
	 *     pathName=ID
	 */
	protected void sequence_PathElementCS(ISerializationContext context, PathElementCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PATH_ELEMENT_CS__PATH_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PATH_ELEMENT_CS__PATH_NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPathElementCSAccess().getPathNameIDTerminalRuleCall_0(), semanticObject.getPathName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PathNameCS returns PathNameCS
	 *
	 * Constraint:
	 *     (path+=PathElementCS path+=PathElementCS*)
	 */
	protected void sequence_PathNameCS(ISerializationContext context, PathNameCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PropertyCS returns PropertyCS
	 *
	 * Constraint:
	 *     (name=ID typeRef=PathNameCS)
	 */
	protected void sequence_PropertyCS(ISerializationContext context, PropertyCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PROPERTY_CS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PROPERTY_CS__NAME));
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.PROPERTY_CS__TYPE_REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.PROPERTY_CS__TYPE_REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyCSAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPropertyCSAccess().getTypeRefPathNameCSParserRuleCall_3_0(), semanticObject.getTypeRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RootCS returns RootCS
	 *
	 * Constraint:
	 *     (packages+=PackageCS | contraints+=ConstraintCS)+
	 */
	protected void sequence_RootCS(ISerializationContext context, RootCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RoundedBracketClauseCS returns RoundedBracketClauseCS
	 *
	 * Constraint:
	 *     (args+=ExpCS args+=ExpCS*)?
	 */
	protected void sequence_RoundedBracketClauseCS(ISerializationContext context, RoundedBracketClauseCS semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ExpCS returns StringLiteralExpCS
	 *     LogicExpCS returns StringLiteralExpCS
	 *     LogicExpCS.LogicExpCS_1_0 returns StringLiteralExpCS
	 *     CallExpCS returns StringLiteralExpCS
	 *     CallExpCS.CallExpCS_1_0 returns StringLiteralExpCS
	 *     PrimaryExpCS returns StringLiteralExpCS
	 *     LiteralExpCS returns StringLiteralExpCS
	 *     StringLiteralExpCS returns StringLiteralExpCS
	 *
	 * Constraint:
	 *     stringSymbol=STRING
	 */
	protected void sequence_StringLiteralExpCS(ISerializationContext context, StringLiteralExpCS semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MiniOCLPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MiniOCLPackage.Literals.STRING_LITERAL_EXP_CS__STRING_SYMBOL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralExpCSAccess().getStringSymbolSTRINGTerminalRuleCall_0(), semanticObject.getStringSymbol());
		feeder.finish();
	}
	
	
}
