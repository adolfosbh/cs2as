import ClassesCS: 'ClassesCS.ecore'::classescs;
import ClassesAS: 'Classes.ecore'::classes;
import ClassesCS2ClassesAS: 'ClassesCS2ClassesAS.ecore'::cCS2cAS;

transformation classesCS2classesAS {
    cAS imports ClassesAS;
    cCS imports ClassesCS;
    middle imports ClassesCS2ClassesAS;    
}

map rootCS2rootAS_LM in classesCS2classesAS {
    check cCS (rootCS : RootCS) {}    
    enforce middle () {
    	realize r2r : RootCS2Root
    }
    
    where () {
    	r2r.rootCS := rootCS;
    }
}

map rootCS2rootAS_MR in classesCS2classesAS {
	check middle(r2r : RootCS2Root){}
	enforce cAS() {
		realize root : Root 
	}
	
	where () {
		r2r.root := root;
	}
}

map packageCS2packageAS_LM in classesCS2classesAS {
    check cCS (packageCS : PackageCS) {}
    enforce middle () {
    	realize p2p : PackageCS2Package
    }
    
    where () {
    	p2p.packageCS := packageCS;    	
    }
}

map packageCS2packageAS_MR in classesCS2classesAS {
	check middle(p2p : PackageCS2Package) {}
	enforce cAS() {
		realize package : Package 
	}
	
	where () {
		p2p.package := package;
	}
}

map rootAS_ownedPackages in classesCS2classesAS {
	check cAS(root : Root, package : Package) {}
	check middle(r2r : RootCS2Root, p2p : PackageCS2Package) {}
	where (	r2r.root = root;
			p2p.package = package;
			r2r.rootCS.ownedPackages->includes(p2p.packageCS);
	) {
		root.ownedPackages := root.ownedPackages->including(package);
	}
}

map packageAS_name in classesCS2classesAS {
	check cAS(package : Package) {}
	check middle(p2p : PackageCS2Package) {}
	where (p2p.package = package;)
	{
		package.name := p2p.packageCS.name;
	}
}