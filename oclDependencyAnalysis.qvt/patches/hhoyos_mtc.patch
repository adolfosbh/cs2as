diff --git a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/MtcBroker.java b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/MtcBroker.java
index 6cc4df1..fe9d0b0 100644
--- a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/MtcBroker.java
+++ b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/MtcBroker.java
@@ -90,7 +90,7 @@
 	private static final String QVTC_FULL_NS = QVTC_URI + "," + QVTCB_URI + "," + QVTB_URI + "," + PIVOT_URI;
 	
 	/** The Constant QVTI_FULL_NS. */
-	private static final String QVTI_FULL_NS = QVTI_URI + "," + QVTCB_URI + "," +  QVTB_URI + "," +  PIVOT_URI;
+	protected static final String QVTI_FULL_NS = QVTI_URI + "," + QVTCB_URI + "," +  QVTB_URI + "," +  PIVOT_URI;
 	
 	/** The Constant QVTS_FULL_NS. */
 	private static final String QVTS_FULL_NS = QVTS_URI + "," + QVTI_FULL_NS;
@@ -132,16 +132,16 @@
 	private String qvtmUri;
 	
 	/** The partition uri. */
-	private String partitionUri;
+	protected String partitionUri;
 	
 	/** The qvti uri. */
-	private String qvtiUri;
+	protected String qvtiUri;
 	
 	/** The config uri. */
 	private String configUri;
 	
 	/** The schedule uri. */
-	private String scheduleUri;
+	protected String scheduleUri;
 	
 	/** The owner clas of the MTC (used to find resources). */
 	private Class owner;
@@ -150,7 +150,7 @@
 	private PivotModel configModel;
 	
 	/** The ocl std lib model. */
-	private PivotModel oclStdLibModel;
+	protected PivotModel oclStdLibModel;
 
 	/** The r metamodel. */
 	private String rMetamodel;
@@ -167,9 +167,9 @@
 	private PivotModel cModel;
 	private PivotModel uModel;
 	private PivotModel mModel;
-	private PivotModel pModel;
-	private PivotModel sModel;
-	private PivotModel iModel;
+	protected PivotModel pModel;
+	protected PivotModel sModel;
+	protected PivotModel iModel;
 
 	
 	/**
@@ -385,7 +385,7 @@
 	 * @throws QvtMtcExecutionException If there is a problem loading the models or
 	 * 	executing the ETL script.
 	 */
-	private PivotModel qvtpToQvts(PivotModel pModel) throws QvtMtcExecutionException {
+	protected PivotModel qvtpToQvts(PivotModel pModel) throws QvtMtcExecutionException {
 		PivotModel sModel = null;
 		sModel = createModel(scheduleUri, "QVTs", "", QVTS_FULL_NS, false, true, false);
 		if (pModel != null && sModel != null  ) {
@@ -415,7 +415,7 @@
 	 * @throws QvtMtcExecutionException If there is a problem loading the models or
 	 * 	executing the EOL script.
 	 */
-	private void qvtpScheduling(PivotModel pModel, PivotModel sModel) throws QvtMtcExecutionException {
+	protected void qvtpScheduling(PivotModel pModel, PivotModel sModel) throws QvtMtcExecutionException {
 		
 		if (pModel != null && sModel != null  ) {
 			EolTask eol = null;
@@ -445,7 +445,7 @@
 	 * @throws QvtMtcExecutionException If there is a problem loading the models or
 	 * 	executing the ETL script.
 	 */
-	private PivotModel qvtpQvtsToQvti(PivotModel pModel, PivotModel sModel) throws QvtMtcExecutionException {
+	protected PivotModel qvtpQvtsToQvti(PivotModel pModel, PivotModel sModel) throws QvtMtcExecutionException {
 		
 		PivotModel iModel = null;
 		iModel = createASModel(qvtiUri, "QVTi", "QVT", QVTI_FULL_NS, false, true, false);
@@ -475,7 +475,7 @@
 	 * @throws QvtMtcExecutionException If there is a problem loading the models or
 	 * 	executing the EOL script.
 	 */
-	private void createContainmentTrees() throws QvtMtcExecutionException  {
+	protected void createContainmentTrees() throws QvtMtcExecutionException  {
 		
 		EolTask eol = null;
 		List<String> loadedUris = new ArrayList<String>();
@@ -512,6 +512,7 @@
 								eol.models.add(mmModel);
 								eol.models.add(treeModel);
 								eol.execute();
+								eol.models.clear();
 								trees.add(treeModel);
 							}
 						}
@@ -557,7 +558,7 @@
 	 *
 	 * @throws QvtMtcExecutionException If there is a problem loading the model.
 	 */
-	private void loadConfigurationModel() throws QvtMtcExecutionException {
+	protected void loadConfigurationModel() throws QvtMtcExecutionException {
 		
 		configModel = createModel(configUri, CONFIG_MODEL_NAME, "", CONFIG_URI, true, false, true);
 	}
@@ -567,7 +568,7 @@
 	 *
 	 * @throws QvtMtcExecutionException If there is a problem loading the model.
 	 */
-	private void loadOclStdLibModel() throws QvtMtcExecutionException {
+	protected void loadOclStdLibModel() throws QvtMtcExecutionException {
 		
 		OCLASResourceFactory.INSTANCE.getClass();
         Resource.Factory.Registry.INSTANCE.getExtensionToFactoryMap( ).put("oclas", OCLASResourceFactory.INSTANCE);
@@ -649,7 +650,7 @@
 	 * @return the pivot model
 	 * @throws QvtMtcExecutionException There was an error loading the model
 	 */
-	private PivotModel createModel(String modeUri, String modelName, String modelAliases, String metamodelUris,
+	protected PivotModel createModel(String modeUri, String modelName, String modelAliases, String metamodelUris,
 				boolean readOnLoad, boolean storeOnDispoal, boolean cached) throws QvtMtcExecutionException {
 	
 		PivotModel model = new PivotModel(metaModelManager, false);
@@ -748,7 +749,7 @@
 	 * @throws URISyntaxException the URI syntax exception
 	 */
 	private String getResourceURI(String resource) throws URISyntaxException {
-		URL r = this.getClass().getResource(resource);
+		URL r = MtcBroker.class.getResource(resource);
 		String uri = r.toURI().toString();
 	    return uri;
 	}
diff --git a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/OCLExpressionAnalysis.eol b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/OCLExpressionAnalysis.eol
index 79d3f3a..c8fb682 100644
--- a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/OCLExpressionAnalysis.eol
+++ b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/OCLExpressionAnalysis.eol
@@ -38,7 +38,7 @@
         for (arg in self.argument) {
            arg.fixVarReferences(v);
         }
-    } else if (self.isTypeOf(QVT!PropertyCallExp)) {
+    } else if (self.isKindOf(QVT!NavigationCallExp)) {
         self.source.fixVarReferences(v);
     } else if (self.isTypeOf(QVT!IfExp)) {
         self.condition.fixVarReferences(v);
diff --git a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/QVTsHelpers.eol b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/QVTsHelpers.eol
new file mode 100644
index 0000000..43fdf2a
--- /dev/null
+++ b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/helpers/QVTsHelpers.eol
@@ -0,0 +1,42 @@
+/*******************************************************************************
+ * Copyright (c) 2014 The University of York and Willink Transformations Ltd.
+ * All rights reserved. This program and the accompanying materials
+ * are made available under the terms of the Eclipse Public License v1.0
+ * which accompanies this distribution, and is available at
+ * http://www.eclipse.org/legal/epl-v10.html
+ * 
+ * Contributors:
+ *     Adolfo Sanchez-Barbudo Herrera (University of York) - initial implementation
+ ******************************************************************************/
+
+--
+-- EOL Utils with helper functions for QVTs models
+--    Model Names/Aliases:
+--       QVTs : A QVTs model
+
+
+
+-- Helper function to obtaion the distinct data of a mapping
+-- with greater amount secondary argument 
+operation QVTs!MappingAction getMainDistinctData() : QVTs!DistinctData {
+	return self.getDistinctDataOrderedBySecondaryArgs().last();
+}
+
+-- Helper function to obtaion the distinct data of mapping
+-- with greater amount secondary arguments
+operation QVTs!MappingAction getDistinctDataOrderedBySecondaryArgs() : Sequence(QVTs!DistinctData) {
+	return self.distinctArguments.sortBy(dd | dd.secondaryArguments.size());
+}
+
+operation QVTs!DistinctData getNextDistinctData() : QVTs!DistinctData {
+	var orderedArgs = self.target.getDistinctDataOrderedBySecondaryArgs();
+	var pos = orderedArgs.indexOf(self);
+	if (pos == 0) {
+		return null;
+	} else {
+		return orderedArgs.at(pos-1);
+	}
+}
+
+
+   
\ No newline at end of file
diff --git a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/MapOrdering.eol b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/MapOrdering.eol
index dfe126d..3d87cd9 100644
--- a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/MapOrdering.eol
+++ b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/MapOrdering.eol
@@ -43,21 +43,24 @@
 	// Do a Depth first search of the containment tree of the output model
 	var queue = new Sequence();
 	// Marked visited mappings to avoid loops
-	var visited = new Sequence();
+	var visitedAct = new Sequence();
+	var visitedNodes = new Sequence();
 	queue.addAll(rTree!Node.all().select(n | n.parent.isEmpty()));
 	while (not queue.isEmpty()) {
 	    var n = queue.first();
 	    queue.remove(n);
+	    visitedNodes.add(n);
 	    // Do stuff with n
 	    //n.println("n ");
 	    //  Find all the mappings that have an output node if this type 
 	    // TODO The ECoreContainment tree should save the actual type so we dont compare names!
-	    for (ma in self.actions.select(aa | aa.results.exists(e | e.type.name = n.EClassName))) {
+	    for (ma in self.actions.select(aa | aa.results.exists(e | e.type.name = n.EClassName)) // FIXME what about mappings which create any subtype?
+	    			.includingAll(self.actions.select(aa | aa.getArguments().exists(e | e.type.name = n.EClassName )))) {
 	        // Find the predecesors and linearize
-	        if (visited.excludes(ma))
-	        	ma.getOrdering(visited);
+	        if (visitedAct.excludes(ma))
+	        	ma.getOrdering(visitedAct);
 	    }
-	    queue.addAll(n.children);
+	    queue.addAll(n.children.excludingAll(visitedNodes));
 	}
 }
 
@@ -107,6 +110,7 @@
 	var concreteSources =  args.collect(a | a.sources).flatten().asSet();
 	var abstractSources = self.schedule.datums.select(cd | 
             args.select(ad | ad.type.isAbstract).exists(ad | cd.super.includes(ad)))
+            -- FIXME why does it need to be abstract? and why not super.super ?
         .collect(a | a.sources).flatten().asSet();
 	return concreteSources.includingAll(abstractSources);
 }
diff --git a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/QVTs-pToQVTi.etl b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/QVTs-pToQVTi.etl
index 36a7cb0..f0adf9f 100644
--- a/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/QVTs-pToQVTi.etl
+++ b/plugins/org.eclipse.qvtd.build.etl/src/org/eclipse/qvtd/build/etl/scheduling/QVTs-pToQVTi.etl
@@ -9,6 +9,7 @@
  *     Horacio Hoyos - initial implementation
  ******************************************************************************/
 import "../helpers/QVTHelpers.eol";
+import "../helpers/QVTsHelpers.eol";
 
 pre {
     var emfTool = new Native("org.eclipse.epsilon.emc.emf.tools.EmfTool");
@@ -94,7 +95,7 @@
                 // Add only the loops of the PrimaryArguments with the most secondary arguments
                 // The other DistinctData loops will be nested inside these
                 mOut.mappingStatement.mappingStatements.addAll(ma.children
-                    .collect(ma | ma.distinctArguments.sortBy(dd | dd.secondaryArguments.size()).last())
+                    .collect(ma | ma.getMainDistinctData())
                     .flatten().equivalent());
             } else {
                 mOut.mappingStatement.mappingStatements.addAll(ma.children.equivalent());
@@ -228,8 +229,15 @@
     to vOut : QVTi!Variable
     extends NamedElements
     {
-        // Not a loop variable
-        guard : not vIn.eContainer.isTypeOf(QVTp!IteratorExp)
+    	-- We want to prevent re-creation of variables which are cloned 
+    	-- from OCL expressions (via ecoreUtil). Let's excludes all those
+    	-- directly contained on an OCLExpression (IteratorExp, LetExp, etc.)
+    	-- ExpressionInOCL containers are also removed, in case the QVTp transformation
+    	-- redfers to other OCL resources 
+        guard { var varContainer = vIn.eContainer();
+        		return (not varContainer.isKindOf(QVTp!OCLExpression)) and
+        			   (not varContainer.isKindOf(QVTp!ExpressionInOCL));
+         }
         
         vOut.implicit = vIn.implicit;
         vOut.type = vIn.type;
@@ -278,13 +286,10 @@
         loop.body = new QVTi!MappingSequence;
         loop.body.mappingStatements.add(dd.target.equivalent());
         // To make loops nest, only one loop can be added. Which? The next one with the most secondary arguments
-        var nextDD = dd.target.distinctArguments.excluding(dd).select(da | da.secondaryArguments.size() < dd.secondaryArguments.size())
-                .sortBy(dd | dd.secondaryArguments.size()).last();
+        var nextDD = dd.getNextDistinctData();
         if (nextDD <> null) {
             loop.body.mappingStatements.add(nextDD.equivalent());
         }        
-        
-        
     }
     
 