grammar uk.ac.york.cs.cs2as.CS2ASDSL with org.eclipse.ocl.xtext.essentialocl.EssentialOCL

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "platform:/resource/org.eclipse.ocl.pivot/model/Pivot.ecore" as pivot
import "platform:/resource/org.eclipse.ocl.xtext.base/model/BaseCS.ecore" as base
import "platform:/resource/org.eclipse.ocl.xtext.essentialocl/model/EssentialOCLCS.ecore" as essentialocl

generate cs2as_dsl "http://www.ac.uk/york/cs/cs2as/CS2ASDSL"

Model:
	csDecl=CSDecl
	asDecl=ASDecl
	
	(mappingSect=MappingSect 
	& disambiguationSect=DisambiguationSect? 
	& nameresoSect=NameResolutionSect?
	& helpersSect=HelpersSect?
	)
;

CSDecl:
	'source' metamodels+=ImportCS (',' metamodels+=ImportCS)*
;

ASDecl:
	'target' metamodels+=ImportCS (',' metamodels+=ImportCS)*
;

ImportCS returns base::ImportCS:
	(name=Identifier ':')? ownedPathName=URIPathNameCS (isAll?='::*')?
;

MappingSect:
	{MappingSect}
	'mappings' '{'
		mappings+=ClassMap*
	'}'	
;
ClassMap:
	'map' to=PathNameCS 'from'  from=PathNameCS  ('when' rule=SIMPLE_ID )? '{'
		statements += ClassMapStmnt*
	'}'
;

ClassMapStmnt:
	PropertyMap
	';'
;

PropertyMap:
	(redefine?='redefine')? propName=SIMPLE_ID ':=' propInit=ExpCS
;

DisambiguationSect:
	{DisambiguationSect}
	'disambiguation' '{'
		disambiguations+=ClassDisambiguation*
	'}'
;

ClassDisambiguation:
	class=PathNameCS '{'
		statements+=ClassDisambiguationStmnt*
	'}'
;

ClassDisambiguationStmnt:
	DisambiguationDef
	';'
;

DisambiguationDef:
	name=SIMPLE_ID ':=' exp=ExpCS
;

NameResolutionSect:
	{NameResolutionSect}
	'name-resolution' '{'
		targetsDef=Targets
		inputsDef=Inputs
		providersDef=Providers
	'}'
;

Targets:
	{Targets}
	'targets' '{'
		targets+=Target*
	'}'
	
;

Target:
	classRef=ClassRef  ('using' propRef=PathNameCS)?
	filter=FilterDef?
	('qualifies' qualifications+=QualificationDef (',' qualifications+=QualificationDef)*)?
	';'
;

Inputs:
	{Inputs}
	'inputs' '{'
		inputs+=Input*
	'}'
;

Input:
	(qualifier?='qualifier')?
	classRef=ClassRef ('using' propRef=PathNameCS)? ';'
;

Providers:
	{Providers}
	'providers' '{'
		providers+=Provider*
	'}'
;
Provider:
	classRef=PathNameCS '{'
		varsDecl=ProviderVars?
		statements+=ProviderStmnt*
	'}'
;

ProviderVars:
	'vars' varDecl+= LetVariableCS (',' varDecl+=LetVariableCS)* ';'
;

ProviderStmnt:
	(ScopeDef | ExportDef) ';'
;

FilterDef:
	'filtered' ('by' params+=ParameterDef (',' params+=ParameterDef)* )? 'when' expression=ExpCS
;

QualificationDef:
	targetsDef=MultipleClassRef
	'using' contribution+=ElementsContribExp
;
	
ElementsContribExp:
	(isPreceding?='preceding' | isImported?='imported'?)? expression=ExpCS 
;

ScopeDef:
	selectionDef=SelectionDef?
	'in'  'current-scope' ('and' alsoExports?='exported-scope')? 'provides'
	('occluding' | sameScope?='adding' | emptyScope?='resetting')?
	provisionDefs+=ProvisionDef+
;

SelectionDef:
	'for'
	( {SelectionAll} 'all' ('excepting' exceptionProperties+=ExpCS (',' exceptionProperties+=ExpCS)*)?
	| {SelectionSpecific} (selectedProperties+=ExpCS (',' selectedProperties+=ExpCS)* )
	)
;

ProvisionDef:
	targetsDef=MultipleClassRef
	'using' contribution=ContributionDef
	occludingDefs+=OccludingDef*
;

ClassRef:
	className=PathNameCS
;

MultipleClassRef:
	classNames+=PathNameCS (',' classNames+=PathNameCS)*	
;

OccludingDef:
	'occluding' contribution=ContributionDef 
;

ContributionDef:
	 contributions+=ElementsContribExp (',' contributions+=ElementsContribExp)* 
;



ExportDef:
	selectionDef=SelectionDef?
	'in' 'exported-scope' 'provides'
	provisionDefs+=ProvisionDef+
;

HelpersSect:
	{HelpersSect}
	'helpers' '{'
		classHelpers+=ClassHelper*
	'}'
;

ClassHelper:
	context=PathNameCS '{'
		helpers+=HelperDef*
	'}'
;

// Similar to Complete OCL definitions
HelperDef:
	(ownedSignature=TemplateSignatureCS)?
	name=UnrestrictedName 
	'(' (params+=ParameterDef (',' params+=ParameterDef)*)? ')' (':' ownedType=TypeExpCS)?
	':=' helperBody=ExpCS
	';'
;

ParameterDef returns base::ParameterCS:
	name=UnrestrictedName ':' ownedType=TypeExpCS;

/* A primary expression identifies the basic expressions from which more complex expressions may be constructed. */
PrimaryExpCS returns essentialocl::ExpCS:
	NestedExpCS
|	IfExpCS
| 	SelfExpCS
| 	PrimitiveLiteralExpCS
| 	TupleLiteralExpCS
| 	MapLiteralExpCS
| 	CollectionLiteralExpCS
| 	LambdaLiteralExpCS
| 	TypeLiteralExpCS
| 	NameExpCS
|	TraceExpCS	// DSL addition
|	LookupExpCS;	// DSL addition

TraceExpCS:
	{TraceExpCS}
	'trace'
;


LookupExpCS:
	('lookup' | fromExp?='lookupFrom') '(' args+=NavigatingArgExpCS (',' args+=NavigatingArgExpCS)* ')'
;